import{_ as l}from"./chunks/ImageWithCaption.aka68_Pk.js";import{D as e}from"./chunks/Divider.85fCW90v.js";import{c as t,o as h,ab as p,H as n,x as i,a}from"./chunks/vendor.cEhGAX-6.js";import"./app.4twKycbs.js";const r="/refactoring/bridge/bridge.png",m=JSON.parse('{"title":"桥接模式","description":"","frontmatter":{},"headers":[],"relativePath":"JS/Patterns/Bridge.md","filePath":"JS/Patterns/Bridge.md","lastUpdated":null}'),k={name:"JS/Patterns/Bridge.md"},F=Object.assign(k,{setup(d){return(o,s)=>(h(),t("div",null,[s[0]||(s[0]=p("",7)),n(l,{src:"/refactoring/bridge/bridge.png",caption:"图形越多,类组合是不是就要更多呢?"}),s[1]||(s[1]=i("p",null,[a("在层级里加上新的形状类型,新的颜色的话,类数量就会呈指数型增长."),i("br"),a(" 比如,加一个三角形类,你就要新增两个子类,每种颜色一个.之后如果又增加一种新颜色,你又要创建三个新子类,每个形状一个.实体特征越多,代码越💩.")],-1)),s[2]||(s[2]=i("h2",{id:"解决办法",tabindex:"-1"},[a("解决办法 "),i("a",{class:"header-anchor",href:"#解决办法","aria-label":"Permalink to “解决办法”"},"​")],-1)),s[3]||(s[3]=i("p",null,[a("这种问题之所以会出现,是因为需要在两种独立维度上扩展形状类:一个是形状,一个是颜色.这种情况在类继承中非常常见."),i("br"),a(" 桥接模式,通过对象组合的方式,解决类继承的问题.也就是说,你将其中一个维度提取到一个独立的类层次中,这样原本的类就可以通过这个类层次的对象引用,获得索引了,而不必在同一个类里声明所有的状态及行为.(?感觉很关键但看不懂)")],-1)),n(l,{src:"/refactoring/bridge/solution-en.png",caption:"通过将层级分为多个相关层级,以避免一个类上因扩展而导致的类爆炸"}),s[4]||(s[4]=p("",6)),n(l,{src:"/refactoring/bridge/bridge-3-en.png",caption:"要在庞大而单一的代码库中作出细小的改变都很困难,因为你不得不清晰了解每段代码的作用.而要在规模更小,定义更规范的模块中作出改变则相对容易"}),s[5]||(s[5]=i("p",null,[a("你可以按特定需求,将各个接口-平台(interface-platform)代码组合提取到独立的类去.可是很快你就发现很多这样的类.类层级又呈指数增长了,因为新界面/新接口又需要不同的类组合."),i("br"),a(" 我们尝试用桥接模式解决这个问题.将我们的类分为两个层级:")],-1)),s[6]||(s[6]=i("ul",null,[i("li",null,"抽象层:应用的GUI层"),i("li",null,"实现层: 操作系统的APIs")],-1)),n(l,{src:"/refactoring/bridge/bridge-2-en.png",caption:"组织跨平台应用的一种方式"}),s[7]||(s[7]=i("p",null,"抽象对象控制应用的展示,将实际的操作委任给链接的实现对象.不同的实现对象是可以交叉使用的,只要它们的接口层是通用的话,这样相同的GUI就可以在Windows和Linux下运行了.",-1)),n(e),s[8]||(s[8]=p("",19))]))}});export{m as __pageData,F as default};
