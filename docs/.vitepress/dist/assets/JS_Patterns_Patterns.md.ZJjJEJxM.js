import{_ as a}from"./app.E6B-SwxD.js";import{c as l,o as r,Z as e}from"./chunks/vendor.GdCD6OUn.js";const S=JSON.parse('{"title":"设计模式的分类","description":"","frontmatter":{},"headers":[],"relativePath":"JS/Patterns/Patterns.md","filePath":"JS/Patterns/Patterns.md","lastUpdated":null}'),i={name:"JS/Patterns/Patterns.md"};function h(o,t,m,p,f,n){return r(),l("div",null,t[0]||(t[0]=[e('<h1 id="设计模式的分类" tabindex="-1">设计模式的分类 <a class="header-anchor" href="#设计模式的分类" aria-label="Permalink to “设计模式的分类”">​</a></h1><blockquote><p>是Javascript设计模式的种类合集, 这篇FCC的文章介绍了一部分,也告知了模式的缘由.<br> 本文先总结前文未包括的,后续方便对前文进行补充.<br> 以下来自<a href="http://www.javier8a.com/itc/bd1/articulo.pdf" target="_blank" rel="noreferrer">GoF</a>一书.属于设计模式的一本&quot;圣经&quot;了.<br> 共23种, 前文介绍了12种.<br> Done 5+适配/装饰/外观/代理 4 + 责任链/迭代器/观察者 3 =12<br> 参考:<a href="https://refactoring.guru/design-patterns/catalog" target="_blank" rel="noreferrer">https://refactoring.guru/design-patterns/catalog</a></p></blockquote><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to “分类”">​</a></h2><p>1 for brief and 2 for in-depth, 0 for left</p><ul><li><p><a href="./A-For-Start.html#创建型模式">Creational Patterns</a></p><ul><li><a href="./A-For-Start.html#抽象工厂模式">Abstract Factory抽象工厂模式</a>√ 1</li><li><a href="./A-For-Start.html#构造者模式">Builder构造者模式</a>√ 1</li><li><a href="./A-For-Start.html#工厂模式">Factory Method工厂方法模式</a>√ 1</li><li><a href="./A-For-Start.html#原型模式">Prototype原型模式</a>√ 1</li><li><a href="./A-For-Start.html#单例模式">Singleton单例模式</a>√ 1</li></ul></li><li><p>Structural Patterns</p><ul><li><a href="./A-For-Start.html#适配器模式">Adapter适配器模式</a>√ 1</li><li><a href="./Bridge.html">Bridge桥接模式</a> 2</li><li><a href="./Composite.html">Composite组合模式</a> 2</li><li><a href="./A-For-Start.html#装饰器模式">Decorator装饰器模式</a>√ 1</li><li><a href="./A-For-Start.html#外观模式">Facade外观模式</a>√ 1</li><li><a href="./Flyweight.html">Flyweight享元模式</a> √ 2</li><li><a href="./A-For-Start.html#代理模式">Proxy代理模式</a> √ 1</li></ul></li><li><p>Behavioral Patterns</p><ul><li><a href="./A-For-Start.html#责任链模式">Chain of Responsibility责任链模式</a>√ 1</li><li><a href="./Command.html">Command命令模式</a> √ 2</li><li>Interpreter解释器模式]() 0</li><li><a href="./A-For-Start.html#迭代器模式">Iterator迭代器模式</a>√ 1</li><li><a href="./Mediator.html">Mediator中介者模式</a> √ 2</li><li><a href="./Memento.html">Memento备忘录模式</a> √ 2</li><li><a href="./A-For-Start.html#观察者模式">Observer观察者模式</a>√ 1</li><li>State状态模式]() 0</li><li><a href="./Strategy.html">Strategy策略模式</a> √ 2</li><li><a href="./Template-Method.html">Template Method模板方法模式</a> √ 2</li><li><a href="./Visitor.html">Visitor访问者模式</a> √ 2</li></ul></li></ul><p>Todo:</p><ol><li>Flyweight √</li><li>Command √</li><li>Mediator √</li><li>Strategy √</li><li>Template Method √</li><li>Visitor √</li><li>Memento √</li><li>Bridge √</li><li>Composite √</li></ol><p>left:</p><ol><li>Interpreter</li><li>State</li></ol><h2 id="简单介绍" tabindex="-1">简单介绍 <a class="header-anchor" href="#简单介绍" aria-label="Permalink to “简单介绍”">​</a></h2><p><a href="./A-For-Start.html">Brief Introduction</a> * 同一篇文章里简要介绍多个模式</p><ul><li><p><a href="./A-For-Start.html#创建型模式"><b>创建型模式</b></a></p><ul><li><a href="./A-For-Start.html#单例模式">单例模式</a></li><li><a href="./A-For-Start.html#工厂模式">工厂模式</a></li><li><a href="./A-For-Start.html#抽象工厂模式">抽象工厂模式</a></li><li><a href="./A-For-Start.html#构造者模式">构造者模式</a></li><li><a href="./A-For-Start.html#原型模式">原型模式</a></li></ul></li><li><p><a href="./A-For-Start.html#结构型模式"><b>结构型模式</b></a></p><ul><li><a href="./A-For-Start.html#适配器模式">适配器模式</a></li><li><a href="./A-For-Start.html#装饰器模式">装饰器模式</a></li><li><a href="./A-For-Start.html#外观模式">外观模式</a></li><li><a href="./A-For-Start.html#代理模式">代理模式</a></li></ul></li><li><p><a href="./A-For-Start.html#行为型模式"><b>行为型模式</b></a></p><ul><li><a href="./A-For-Start.html#责任链模式">责任链模式</a></li><li><a href="./A-For-Start.html#迭代器模式">迭代器模式</a></li><li><a href="./A-For-Start.html#观察者模式">观察者模式</a></li></ul></li></ul><h2 id="完整介绍" tabindex="-1">完整介绍 <a class="header-anchor" href="#完整介绍" aria-label="Permalink to “完整介绍”">​</a></h2><p><strong>In-depth patterns(每一个模式都是一篇文章)</strong></p><ul><li><p><a href="./Bridge.html">Bridge桥接模式</a></p></li><li><p><a href="./Composite.html">Composite组合模式</a></p></li><li><p><a href="./Flyweight.html">Flyweight享元模式</a></p></li><li><p><a href="./Command.html">Command命令模式</a></p></li><li><p><a href="./Mediator.html">Mediator中介者模式</a></p></li><li><p><a href="./Memento.html">Memento备忘录模式</a></p></li><li><p><a href="./Strategy.html">Strategy策略模式</a></p></li><li><p><a href="./Template-Method.html">Template-Method模板方法模式</a></p></li><li><p><a href="./Visitor.html">Visitor访问者模式</a></p></li></ul>',15)]))}const F=a(i,[["render",h]]);export{S as __pageData,F as default};
