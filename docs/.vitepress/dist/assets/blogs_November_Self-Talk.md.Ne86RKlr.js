import{_ as s}from"./app.D_13B_sJ.js";import{c as a,o as i,_ as t}from"./chunks/vendor.bZs7jcXh.js";const u=JSON.parse('{"title":"一通自言自语","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/November/Self-Talk.md","filePath":"blogs/November/Self-Talk.md","lastUpdated":1732534178000}'),l={name:"blogs/November/Self-Talk.md"};function n(r,e,o,d,c,h){return i(),a("div",null,e[0]||(e[0]=[t(`<h1 id="一通自言自语" tabindex="-1">一通自言自语 <a class="header-anchor" href="#一通自言自语" aria-label="Permalink to “一通自言自语”">​</a></h1><p>是无意义的自我对话,是阅读后的自我总结,虽然也不知道做过的,读过的还能记得多少,但以之前的经验来看,这样做还算不错.<br> 之前读过的书,做过的书评虽然大部分都不记得了,但做个summary,跟自己对话一下,self-taught,告诉一下自己看过什么,可能比无意义地略过更容易记住.</p><p>废话到此.</p><h2 id="react-docs" tabindex="-1">React docs <a class="header-anchor" href="#react-docs" aria-label="Permalink to “React docs”">​</a></h2><p><a href="https://react.dev/learn/referencing-values-with-refs" target="_blank" rel="noreferrer">https://react.dev/learn/referencing-values-with-refs</a><br><code>useRef</code>, 直观理解为没有<code>setState</code>的<code>useState</code>.</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myUseRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">initialValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nouse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialState);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仅用于理解</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>差别可以说很多:</p><ol><li>组件状态的变化会引起重渲染,<code>useRef</code>不会re-render(官网的challenge2,on/off)</li><li>一般用<code>useRef</code>来存不用于视图展示的值,因为它的更新不会引起重渲染,变了都不知道.<br> 可以用它来存跨越renders之间的值.challenge1就是用<code>useRef</code>区分/记住某个interval返回的ID,并依据该ID进行<code>clearInterval</code></li><li>变了都不知道的另一个原因是,<code>useRef</code>返回的是带有<code>current</code>属性的普通对象,你可以直接对它进行修改. <code>textRef.current = e.target.value;</code>是可以的,不像<code>useState</code>必须用<code>setState</code>.</li><li>不重渲染之余,<code>useRef</code>可以获取到最新的值.(challenge4,明显突出state和ref在获取值时的区别)</li></ol><p>感觉很好理解的一种方式是, <code>ref</code>是<code>state</code>的<strong>escape hatch</strong>.都可以用来存东西,但时间跨度不一样:<strong>一个是snapshot,一个是across renders.</strong>(希望读到这的你也能区分这里说的哪个是state,哪个是ref.)</p><h2 id="clear-thinking" tabindex="-1">Clear Thinking <a class="header-anchor" href="#clear-thinking" aria-label="Permalink to “Clear Thinking”">​</a></h2><p>自从上次看到的四个self, 后面内容就没继续了.甚至四个self都要忘记有什么了:(重新找书找出来的)</p><ol><li>self-knowledge</li><li>self-confidence</li><li>self-accountability</li><li>self-control(?)</li></ol><p>前4节分别解释了这四个分别是什么,后4节仅用两个例子解释,how to combine?? 某个决策如何体现这四个方面? 怪怪的,然后转向model,idol的作用.</p><hr><p>比较有感触的点是:</p><ol><li>优秀的人有更高的标准: 达到普通的标准,你就会和大部分人一样,达到普通的结果;想要杰出,就需要有更高的标准.</li><li>周围的人,周围的环境在不断无意识地塑造着你. 你选择了与什么人交往,也就选择了怎么样的自己. Most of time,people around us are chosen by chance, instead of our will.(大意是这样)</li><li><strong>Personal Boards of directors:</strong> 属于自己的&quot;董事会&quot;.就是你idol的合集,可以是任何人,(前人,虚构人,现实人,手机人),只要他们身上有值得你去学习的点,他们就都可以&quot;加入&quot;到你的&quot;决策候审团&quot;中.</li><li>现实环境中我们遇到的人可能无法全然让我们去选择,但手机世界不一样:**我们可以主动选择,自己想模仿,自己想成为的,一切可能的人物.**我们可以去读喜欢的人的作品,看喜欢的人的演讲,了解他们的思想,了解他们的习惯,从而&quot;让他们成为我们自己&quot;.</li><li>&quot;人无完人&quot;,当然偶像也会有缺点,不过关系不大,我们要学的是他们的优点.实在受不了了,瑕掩不了瑜了,那就把他fire掉.自己的董事会,自己选择!</li></ol><hr><p>现在的自言自语,是&quot;费曼学习法&quot;的一种.虽然感觉把自己脑海里的东西写下来,是用来忘记,也是用来记忆的,但,还挺有趣?<br> todos写下来就是为了忘记;读书笔记写下来是为了教育自己,整理自己看过什么内容.<br> 就此,不如去了解一下费曼学习法? 好主意!</p>`,18)]))}const f=s(l,[["render",n]]);export{u as __pageData,f as default};
