import{p as l,o as t,c as n,t as k,a0 as a,G as p}from"./chunks/framework.CGHvQLJz.js";const e={__name:"Counter",setup(h){const i=l(0);function s(){i.value++}return(d,E)=>(t(),n("button",{onClick:s,class:"text-2xl font-sants bg-purple-700 text-white px-2 py-1"}," You clicked "+k(i.value)+" times ",1))}},o=JSON.parse('{"title":"两个React","description":"","frontmatter":{},"headers":[],"relativePath":"react/Blogs/Dan-Abramov/The-Two-Reacts.md","filePath":"react/Blogs/Dan-Abramov/The-Two-Reacts.md"}'),r={name:"react/Blogs/Dan-Abramov/The-Two-Reacts.md"},c=Object.assign(r,{setup(h){return(i,s)=>(t(),n("div",null,[s[0]||(s[0]=a('<h1 id="两个react" tabindex="-1">两个React <a class="header-anchor" href="#两个react" aria-label="Permalink to &quot;两个React&quot;">​</a></h1><blockquote><p><a href="https://overreacted.io/the-two-reacts/" target="_blank" rel="noreferrer">https://overreacted.io/the-two-reacts/</a><br> 作者:Dan Abramov<br> 是一月的Blog了,2024.5月的React Conference上,Dan也有根据这篇文章介绍了相似概念.<br> 就,相当于Conference的一篇手稿吧.<br> 12:38 - 1:37</p></blockquote><p>假设我需要在你屏幕上显示一些东西,无论是一个网页,一个应用,或者是一个从应用商城上下载来的APP,这个过程中,必然至少含有两个设备:<strong>你的设备,还有我的设备</strong>.<br> 过程的开始,是从我设备上的代码及数据出发的.比如说,我先要在我电脑上写出一篇文章的内容.而如果你能看到我写的这些内容,说明我电脑上的东西,已经通过某些过程,转化成HTML,Javascript,从而展示到你的设备之上了.<br> 什么?你说这跟React有什么关系?如果你不是开发者,你或许不需要了解这个过程.但看到这篇文章的你,大概是React开发者吧.React的编程范式是基于构建UI的,它允许开发者将内容分解开来(一篇博客,一个注册表格,或是一整个应用),由一个个独立的组件,像搭乐高积木一样,一块一块组合起来.你应该知道并很喜欢组件这个概念了吧.如果不是很了解可以去<a href="http://react.dev" target="_blank" rel="noreferrer">react.dev</a>官网看看.<br> 组件就是代码,而这些代码需要在某个地方运行起来它才能发挥作用.等等--它要在哪台电脑上运行呢?你的?还是我的呢?<br> 试试说明一下到底需要在哪台电脑上运行这些代码吧.</p><hr><p>如果说这些组件代码要在你的电脑上运行.<br> 这是一个展示交互的,简单得不得了的计数按钮.试试点几次?</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div>',6)),p(e),s[1]||(s[1]=a(`<p>假如说要渲染这个组件的JS代码已经加载好了,那你每次按这个按钮,计数器就会加一.其中一点延迟没有,不需要等待服务器回应,也不需要从服务器中获取额外的数据.<br> 按这个道理说,这个组件的代码是在你的电脑上运行的:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dark:color-white rounded-lg bg-purple-700 px-2 py-1 font-sans font-semibold text-white focus:ring active:bg-purple-600&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      You clicked me {count} times</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的<code>count</code>是一个客户端的状态(client state)--是你电脑内存里的部分,你每按一次它,这个状态就会更新一次.<strong>我不知道你会按它多少次</strong>,我也就不可能在我的电脑上,预测并为这个状态作出所有可能的输出(predict and prepare).在我电脑上最敢肯定的一件事就是,<strong>这个计数器最开始是从0开始的.</strong> 我把它转化为HTML之后,它要怎么变,就<em>归你的电脑所管</em>了.</p><p>你或许会说,就这也用得着在我的电脑上运行?不直接在服务器上运行?为什么不在我每次按按钮的时候,询问服务器接下来要怎样渲染我的组件?在客户端JS框架出生之前不就是这么做的吗?</p><p>是的,确实如此:如果用户只想有一点点延迟,只感觉到一点点卡的时候确实可以这么做<br> --比如说点到一个超链接.用户知道要在应用内跳转的时候,他们早就料到了会有一点点白屏时间. 不过,不是所有操作用户都有心理准备的--你不能让用户在你应用中随便干点什么都卡.</p><p>像网页下拉,切换标签,打字之后显示到对应框,点击按钮,切换卡片,悬停菜单,图标拖拽等等,用户的操作可太多了.<strong>如果你的网页干点这些简单到不得了的东西都让用户感觉到卡,那就,就就就,完犊子了.</strong> 当然这不是强制的,如果你作为开发者能接受完犊子的话,只是用户很可能不会再用你的网页而已啦?<br><strong>用户希望每个动作都是有反馈的.</strong><br> 比如搭电梯,你知道按了楼层按钮不会立马到达对应楼层,但你按了按钮后,按钮的高亮,是作为最基本的反馈,表明你已经向电梯说明了你要去第几层.推门把手时也是,门没锁的话,你扭动推开后门不立即打开,你肯定就怀疑门把手是不是坏了,而不是我这个动作会导致门把手&quot;有延迟&quot;(这个想法还挺搞笑的哈哈哈哈).</p><p><strong>作为开发者,在构建网页时,要尽可能快地响应用户的操作.(低延迟,&quot;零&quot;网络往返感知)</strong></p><p>你之前可能在哪里看过,React的心智模式可以理解为像这样的等式:<em>UI是状态的一个函数,或者说<code>UI=f(state)</code>.</em> 这当然不是简单的意味着UI在字面上只是作为接收状态的一个简单函数;它想说的是页面的展示取决于当前的状态.当状态被改变,页面就要重新计算展示.由于这些状态是在你的电脑里面的,重新计算要展示的界面这个过程,自然也在你的电脑上进行了.<br> 为什么代码要在你的电脑上运行,这个概念大概就解释完了,接着我们换过来说一下,代码为什么又要在我的电脑上运行?</p><hr><p>所以,为什么代码还要在我(作者,写代码的人)的电脑上运行呢?<br> 这是一个介绍另外一篇博客的概要卡片:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PostPreview</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a-chain-reaction&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>// Todo, &lt;PostPreview /&gt;,一个统计网页字数的组件 这个组件又是怎么知道,另一个页面有多少个字的呢?(牛)<br> 如果你在开发者工具中看Network标签,你会看到其中并没有额外的请求(没有请求访问这个另外的页面).我没有为了统计这个另外的页面,而另外的将这一整篇的文章下载下来.我也没有把这个页面的内容添加到我这篇文章当中.我没有调用任何API来统计字数(?真的没有吗).当当然然,我没有自己一个一个字的去数那篇文章有多少个字.(XD)<br> 所以这个组件是怎么实现的呢?</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { readFile } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fs/promises&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> matter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;gray-matter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostPreview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">slug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./public/&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slug </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/index.md&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;utf-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是Dan本地的,知道文章文件组织后编写的代码,随便换一个项目这个路径就变了,所以我要怎么在本地拼接呢???</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> matter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileContet);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wordCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">split</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Boolean).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">section</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;rounded-md bg-black/5 p-2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h5</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;font-bold&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slug} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_blank&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          {data.title}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{wordCount} words&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个组件在我的电脑上,运行时自然畅通无阻了.我用<code>fs.readFile</code>来读取一个文件,用<code>gray-matter</code>来编译Markdown语法的标题,用<code>split,length</code>这些属性就能统计字数.<strong>我根本不用额外做什么,我的代码正好就在这些数据上运行.</strong> (直接操作这些数据)<br> 如果我要列举出我所有的博客的标题跟对应字数统计呢?<br> 这可太简单了. (???怎么用Vue重写aaaa)</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PostList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>// Todo &lt;PostList/&gt;<br> 我要做的只是为每一个post文件夹渲染对应的<code>&lt;PostPreview/&gt;</code>就可以了:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { readDir } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fs/promises&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { PostPreview } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./post-preview&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PostList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entries</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readdir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./public/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {withFileTypes:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dirs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fitler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isDiretory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mb-4 flex h-72 flex-col gap-2 overflow-scroll font-sans&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {dirs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PostPreview</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{dir.name} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{dir.name} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上的代码完全不需要在你的电脑上运行--想跑也跑不动,你的电脑上也没有我的文件.<br> 看看上面这段代码是什么时候运行的吧?</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text-purple-500 font-bold&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>//Todo &lt;WhenItRuns /&gt;<br> 啊哈--这是我上次静态部署网页时候的时间!我的组件代码在打包的时候被运行了!这样服务器就知道我的博客有哪些,再统计对应字数了!<br><strong>像这样,组件跟数据源相近,它就能直接读取数据,将数据预处理,之后再发送给你的设备了</strong>(总感觉话里有话??)<br> 其实在你加载完这个页面的时候,早就没有什么<code>&lt;PostList&gt;,&lt;PostPreview&gt;,fileContent,dirs,fs,gray-matter</code>这些奇奇怪怪的东西了(有的,有更奇怪的东西,被编译后的东西).取而代之的是<code>&lt;div&gt;,&lt;section&gt;,&lt;a&gt;,&lt;i&gt;</code>,各种嵌套而已了.你的设备上<em>接收到的界面,只是一些必须要展示的东西</em>而已了(对应博客标题,超链接,字数统计这些),不是组件需要的,电脑用来计算UI展示的完整&quot;原数据&quot;了(就是本来超链接里的实际博客).<br> 用这种观念去想的话,<em>UI是服务器数据的一个函数,或者说<code>UI=f(data)</code>.</em> 这里的数据只存在于我的设备上,当然这个组件也应该是在我的电脑上运行了.<br> 到这也就解释完组件为什么需要在我的电脑上了.</p><hr><p>UI是由组件组成的,不过我们可以从两个完全不同的角度去看待:</p><ul><li><code>UI=f(state)</code>,这里的<code>state</code>是在客户端上的,<code>f</code>直接在客户端上运行.这种方式适合编写那些需要立即跟用户交互的组件,像上面的<code>&lt;Counter/&gt;</code>组件.(这里的<code>f</code>也可以是在服务器端上运行,用最初状态生成HTML后交给客户端.?Counter的0吗?)</li><li><code>UI=f(data)</code>,<code>data</code>是在服务器上的,<code>f</code>只在服务器上运行.这种方式适合编写需要数据处理的组件,像<code>&lt;PostPreview/&gt;</code>(这里的<code>f</code>只能在服务器上运行.构建部署的时候作为服务器运行<code>f</code>).</li></ul><p>如果它们不是长得很像的话,其实它们各自都能很好地发挥自己的作用的.不过,如果真的把这两种观念抽出来讲,它们又好像是互不兼容的.(?为什么说是互不兼容?)<br> 需要即时交互(像<code>&lt;Count/&gt;</code>),就要客户端运行代码;需要数据处理(像<code>&lt;PostPreview/&gt;</code>),又不能在客户端上运行,因为它用了像<code>readFile</code>这样的<code>服务器端API</code>.(这就很矛盾了,如果不是用了这种API的话它也可以在客户端上运行了.)<br> 好吧,既然如此那就全在服务器端上跑好了.可是可是,在服务器端上像<code>&lt;Counter/&gt;</code>这样的组件,又只能渲染初次状态(initial state).服务器不知道交互后这个状态会发生什么变化,如果真要每次都server-client-server-client这样传递那简直不要太慢,很多情况下也不现实.(比如说我的&quot;博客服务器&quot;,只在我部署那刻才运行,你传数据给我是没有用的).<br> 难道我们真的只能二选一了吗?</p><ul><li>客户端<code>UI=f(state)</code>,写<code>&lt;Counter/&gt;</code>类组件;</li><li>服务器端<code>UI=f(data)</code>,写<code>&lt;PostPreview/&gt;</code>类组件.</li></ul><p>当然不是,现实更像是,<code>UI=f(data,state)</code>,我全都要!实际开发中没有<code>data</code>或者没有<code>state</code>,应用当然也是能跑的.只不过理想的情况是两种情况都能兼顾,不用再去想另外的抽象概念--你应该也想这样吧?<br> 我们要解决的问题,是如何把这里的<code>f</code>,同时应用到两种变成环境当中.这真的可能吗?回想一下,这里的<code>f</code>不是真正的函数,它代表着我们所有的组件.<br> 我们能不能把组件通过某种方式,划分成在你电脑上运行的,以及在我电脑上(服务器端)运行的呢?当然中间还要保留它是React的组件.(划着划着不是React组件了那还的了哈哈哈哈).<br> 我们是否可以组合嵌套两种不同的环境呢?<br> 具体又要怎么实现呢?<br> 怎么办呢怎么办呢?<br> 想想吧~下次我们来比较一下我们的笔记~</p><hr><p>(Thanks for watching,其实Dan在2024ReactConf上已经给出解决方案了,<code>&#39;use client&#39;和&#39;use server&#39;</code>,一个1月,一个5月.对比一下Dan的presentation和blog,发现还挺一体的,通俗,幽默,又不乏创新.不愧是我偶像!)</p><p>// 三个React写的组件要怎么用Vue写aaaaa</p>`,29))]))}});export{o as __pageData,c as default};
