import{_ as a,c as e,o as i,a3 as t}from"./chunks/framework.oAOP1Qjo.js";const s="/assets/caching-overview.oGsa81w4.jpg",l="/assets/deduplicated-fetch-requests.0cE0fW-n.jpg",n="/assets/request-memoization.DV_nA8x9.jpg",o="/assets/data-cache.DeryaTV9.jpg",h="/assets/time-based-revalidation.WLFj3TjG.jpg",r="/assets/on-demand-revalidation.rdxf3BsI.jpg",c="/assets/full-route-cache.CAr5tDmi.jpg",d="/assets/static-and-dynamic-routes.HzG_RODo.jpg",F=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[],"relativePath":"react/Next/Official-Docs/Cache/Full-Content.md","filePath":"react/Next/Official-Docs/Cache/Full-Content.md"}'),p={name:"react/Next/Official-Docs/Cache/Full-Content.md"},k=t('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h1><p>Next通过缓存渲染内容及减少数据请求的方式,提升应用性能,减少工作花费.<br> 本文较为深入地介绍了,Next内部地缓存机制、一些配合使用的APIs,以及如何协调使用这些API配置.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>本页的内容是帮助你理解,Next底层的一些缓存工作原理的,非必要,对你产能可能没有帮助.<br> 大部分缓存的内容及实践,是由你如何使用API决定的.默认情况下Next已经帮你尽可能地将它们用于提供最好的性能配置了,你需要配置内容的可以说是没有,或是尽可能少了.<br> (大概这是我一直拖延翻译这章的一个理由?嗯对一定是)</p></div><h2 id="概况" tabindex="-1">概况 <a class="header-anchor" href="#概况" aria-label="Permalink to &quot;概况&quot;">​</a></h2><p>下图是对不同缓存机制以及相应操作目的的一个总结:</p><table><thead><tr><th>机制</th><th>是什么</th><th>在哪里执行</th><th>执行目的</th><th>执行持续时间</th></tr></thead><tbody><tr><td>&quot;记忆请求&quot;</td><td>函数的返回值</td><td>服务器上</td><td>在组件树内重用数据</td><td>每次请求周期</td></tr><tr><td>数据缓存区</td><td>数据</td><td>服务器上</td><td>用户请求和部署期间存储数据</td><td>持久化存储(可被重校验)</td></tr><tr><td>完整路由缓存</td><td>HTML和RSC Payload</td><td>服务器上</td><td>减少渲染耗费的资源,提升性能</td><td>持久化存储(可被重校验)</td></tr><tr><td>路由器缓存</td><td>RSC Payload</td><td>客户端上</td><td>减少导航时向服务器发送的请求量</td><td>客户会话时间内,或是某个设定时间内</td></tr></tbody></table><p>Next默认会尽可能地对内容进行缓存,以提升应用性能及减少耗费.也就是说你不专门设置的话,<strong>路由会被静态渲染,数据请求会被缓存</strong>.下图展现的是默认缓存行为的工作过程:路由在构建时被静态渲染,以及首次访问一个静态路由的情况: <img src="'+s+'" alt="caching-overview"> 缓存的行为,取决于:1. 路由是静态/动态渲染;2. 数据是否需要被缓存;3. 某个请求,是初次访问就要用到/还是后续导航才用到.根据具体的使用场景,你可以为单独的路由/请求设置,单独地设置缓存行为.</p><h2 id="记忆请求-request-memoization" tabindex="-1">记忆请求(Request Memoization) <a class="header-anchor" href="#记忆请求-request-memoization" aria-label="Permalink to &quot;记忆请求(Request Memoization)&quot;">​</a></h2><p>Next扩展了<code>fetch</code>这个API,会自动地对请求进行&quot;记忆&quot;.同时也保留了原有的URL,配置选项设置.<br> 换句话说,你可以在组件树内,在不同地方调用获取相同数据的<code>fetch</code>请求.Next能确保<strong>它们只会被执行一次</strong>. <img src="'+l+`" alt="request-memoization"> 比如说你要在一个路由中使用相同的数据,(一个路由包括Layout,Page,多个Components等等..),你<strong>不需要</strong>在组件树的顶部请求数据,然后利用props传递给子组件.你可以直接在需要这些数据的组件中调用获取函数,不用担心可能会产生的多个重复请求造成性能的损耗问题.(你调用了多个请求,实质Next一个叛逆就不给你执行了.Next觉得你请求来的都是相同数据,所以选择缓存而不是&quot;亲力亲为&quot;).</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/example.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // \`fetch\`函数会被&quot;记忆&quot;,请求结果会被缓存.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 被调用了两次,但实际只会执行第一次.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cache MISS.缓存没有对应内容,&quot;亲力亲为&quot;去服务器请求数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cache HIT.缓存由对应请求及内容,选择使用缓存,不去发送真正的请求.</span></span></code></pre></div><h3 id="请求记忆是如何实现的" tabindex="-1">请求记忆是如何实现的? <a class="header-anchor" href="#请求记忆是如何实现的" aria-label="Permalink to &quot;请求记忆是如何实现的?&quot;">​</a></h3><p><img src="`+n+`" alt="request-memoization"></p><ul><li>渲染路由的时候,由于是第一次,因此会专门调用请求,请求的结果当然也不会存在于内存中,缓存就会处于缺失MISS状态.</li><li>因此,函数会在此时被执行,数据也会从外部资源处获取回来,各种结果则会相应存储于内存当中.</li><li>后续的,同一个渲染经过(render pass)内的请求函数调用,则会命中缓存区(HIT),数据也会直接从内存中直接返回,而不用再执行获取函数.</li><li>当路由被渲染完成,渲染过程也结束后,内存会被&quot;重置(reset)&quot;,所有的请求记忆也会被清除.(?怎么判定render pass结束了?)</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>请求记忆是React的一个特性,它并不是Next特有的.我们在这介绍这个特点,是要展示它是如何结合其它缓存机制,一起工作的.</li><li>记忆功能仅适用于<code>fetch</code>请求的<code>GET</code>方法.</li><li>记忆功能仅适用于React组件树,换句话说是: <ul><li><code>generateMetaData</code>,<code>generateStaticParams</code>,布局组件,页面组件,及其它服务器组件,这些组件内的<code>fetch</code>请求,都会适用这种缓存机制.</li><li><strong>路由处理器里的<code>fetch</code>请求不适用这种机制,</strong> 因为它们不属于组件树的一部分.</li></ul></li><li>一些场合下可能用不了<code>fetch</code>请求(比如数据库客户端,CMS客户端,或是GraphQL客户端).这种情况下你可以考虑适用React提供的<code>cache</code>工具函数,来记忆你需要缓存的相应函数.</li></ul></div><h3 id="持续时间" tabindex="-1">持续时间 <a class="header-anchor" href="#持续时间" aria-label="Permalink to &quot;持续时间&quot;">​</a></h3><p>缓存的持续时间,是一个服务器请求生命周期,组件树渲染完后,缓存也将消失.</p><h3 id="重校验" tabindex="-1">重校验 <a class="header-anchor" href="#重校验" aria-label="Permalink to &quot;重校验&quot;">​</a></h3><p>由于这种记忆功能并不能跨请求共享,也只有渲染期间才生效,因此我们没有必要对这种缓存进行重校验.</p><h3 id="选择不使用这种机制-opting-out" tabindex="-1">选择不使用这种机制(Opting out) <a class="header-anchor" href="#选择不使用这种机制-opting-out" aria-label="Permalink to &quot;选择不使用这种机制(Opting out)&quot;">​</a></h3><p>这种记忆功能只会应用于<code>fetch</code>的<code>GET</code>方法,其它比如<code>POST</code>,<code>DELETE</code>等方法结果都是不会被缓存的.这种默认行为属于React的一种优化机制,我们并不建议取消这种功能机制.<br> 如果要对特定的某个请求进行设置,你可以使用<code>AbortController</code>的<code>signal</code>属性来实现.不过这也不会导致行为发生变化,而只会中断进行中的请求.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/example.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbortController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url,{signal});</span></span></code></pre></div><h2 id="数据缓存区" tabindex="-1">数据缓存区 <a class="header-anchor" href="#数据缓存区" aria-label="Permalink to &quot;数据缓存区&quot;">​</a></h2><p>Next内置了一个数据缓存区,用以持久化服务器请求及部署时的数据请求结果.这也属于Next扩充<code>fetch</code>API的一个结果,扩充后每个请求自身,就能设置在服务器上的持久时间了.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在浏览器看来,<code>fetch</code>请求的<code>cache</code>设置项,表明该请求如何与浏览器的HTTP缓存交互.在Next看来,这个<code>cache</code>配置项,表明该请求如何与服务器端的数据缓存区进行交互.(? browser cache -&gt; HTTP cache/ Next cache -&gt; Data Caches&#39; cache | server cache)</p></div><p>你可以使用<code>cache</code>和<code>next.revalidate</code>选项来为<code>fetch</code>请求设置缓存行为.</p><h3 id="数据缓存区是如何工作的" tabindex="-1">数据缓存区是如何工作的? <a class="header-anchor" href="#数据缓存区是如何工作的" aria-label="Permalink to &quot;数据缓存区是如何工作的?&quot;">​</a></h3><p><img src="`+o+`" alt="data-cache"></p><ul><li>第一次请求时,带有<code>force-cache</code>的<code>fetch</code>请求会在渲染时被调用(?).Next会检查数据缓存区是否有对应的,已经缓存了的响应.</li><li>如果区域内存在缓存响应,则它会被立即返回,并被记忆下来(?)</li><li>而如果缓存响应不存在,则会向数据源发出请求,相应的结果则会被存于数据缓存区,并被记忆下来.(stored, 和memoized的区别?)</li><li>对于那些没被缓存的请求(比如请求中没专门设置<code>cache</code>配置项,或<code>{cache:&#39;no-store&#39;}</code>),则会被每次重新从数据源中获取,记忆.</li><li>无论请求结果是否被缓存,请求本身都会被Next所记住.这样才能在React渲染过程中避免相同数据的重复请求.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>数据缓存区和记忆请求的区别</strong><br> 两种机制都通过重用缓存数据以提升性能.区别是持续时间的不同:数据缓存区的数据会持久化于接收请求时与部署时;请求记忆吃灰维持于一个请求周期内.</p></div><h3 id="持续时间-1" tabindex="-1">持续时间 <a class="header-anchor" href="#持续时间-1" aria-label="Permalink to &quot;持续时间&quot;">​</a></h3><p>数据缓存区的内容会持久化于接收请求时与部署时.除非你专门重校验某个特定请求,或选择不使用这个功能,持续时间才会发生变化.</p><h3 id="重校验-1" tabindex="-1">重校验 <a class="header-anchor" href="#重校验-1" aria-label="Permalink to &quot;重校验&quot;">​</a></h3><p>缓存过的数据可以用以下两种方式进行重校验:</p><ul><li>基于时间的重校验: 经过特定时间后重新发起请求,对相应数据进行重校验.这对那些不经常变化的数据,或数据实时性没那么重要的内容比较有用.</li><li>基于需求的重校验: 基于事件的重校验(如表单提交时重校验某些数据).你可以用标签式,或是路径式的按需重校验,同时对某个分组的数据进行重校验.这在你需要确保最新数据尽可能快展示给用户时的场景下相当好用(比如当headless CMS内容变化时)</li></ul><h4 id="基于时间的重校验" tabindex="-1">基于时间的重校验 <a class="header-anchor" href="#基于时间的重校验" aria-label="Permalink to &quot;基于时间的重校验&quot;">​</a></h4><p>你可以在<code>fetch</code>选项的<code>next.revalidate</code>属性上,为数据获取添加一个时间间隔,从而为<code>fetch</code>获取到的数据缓存设置一个生存时间.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{ next: { revalidate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要是静态值而不能是evaluated的值, 60 * 60也不可以, 单位是秒</span></span></code></pre></div><p>如果你要重校验一个路由分块内的所有<code>fetch</code>请求,或者某些无法使用<code>fetch</code>请求的场景,你可以用<a href="https://nextjs.org/docs/app/building-your-application/caching#segment-config-options" target="_blank" rel="noreferrer">分块配置项(Segment config options)</a></p><h4 id="基于时间的重校验是如何实现的" tabindex="-1">基于时间的重校验是如何实现的 <a class="header-anchor" href="#基于时间的重校验是如何实现的" aria-label="Permalink to &quot;基于时间的重校验是如何实现的&quot;">​</a></h4><p><img src="`+h+'" alt="time-based-revalidation"></p><ul><li>首次带有<code>revalidate</code>选项的请求被调用时,数据会从外部数据源中返回,并存储到数据缓存区.</li><li>特定时间帧内的所有请求(比如60秒),都会返回对应的缓存数据</li><li>特定时间帧过后,下一个请求依旧会返回缓存中的数据(已经过期了的) <ul><li>Next后台会触发数据重校验</li><li>如果新数据成功返回,Next会用这些新鲜数据替代掉数据缓存区对应的过时内容.</li><li>如果重校验获取失败,则对应请求依旧返回过时数据</li></ul></li></ul><p>以上行为实际上与<a href="https://web.dev/stale-while-revalidate/" target="_blank" rel="noreferrer"><code>stale-while-revalidate(SWR)</code></a>的行为相似.</p><h4 id="基于需求的重校验" tabindex="-1">基于需求的重校验 <a class="header-anchor" href="#基于需求的重校验" aria-label="Permalink to &quot;基于需求的重校验&quot;">​</a></h4><p>基于需求的重校验可以通过路径重校验,或是标签重校验的方法实现.(<code>revalidatePath</code>,<code>revalidateTag</code>)</p><h4 id="基于需求的重校验是如何实现的" tabindex="-1">基于需求的重校验是如何实现的 <a class="header-anchor" href="#基于需求的重校验是如何实现的" aria-label="Permalink to &quot;基于需求的重校验是如何实现的&quot;">​</a></h4><p><img src="'+r+'" alt="on-demand-revalidation"></p><ul><li>首次<code>fetch</code>请求被调用时,数据会从外部数据源返回,并存于Next数据缓存区.</li><li>当按需重校验被触发时, 相应的已缓存项就会被删除.这跟基于时间的重校验行为不同,后者只会在新数据返回后再覆盖旧的缓存数据.</li><li>触发下次请求后,状态依旧会是缓存缺失(MISS),再次从外部数据源中获取回来.</li></ul><h4 id="选择不使用这种机制" tabindex="-1">选择不使用这种机制 <a class="header-anchor" href="#选择不使用这种机制" aria-label="Permalink to &quot;选择不使用这种机制&quot;">​</a></h4><p>如果你不想对响应进行缓存,可以这样做:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url,{cache:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;no-cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="全路由缓存" tabindex="-1">全路由缓存 <a class="header-anchor" href="#全路由缓存" aria-label="Permalink to &quot;全路由缓存&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>相关术语:</strong><br> 下文可能使用<code>自动化静态优化</code>,<code>静态网站生成</code>,或是<code>静态渲染</code>这些术语,它们指代的都是在构建时渲染及缓存应用路由的这个过程.</p></div><p>Next自动在构建时渲染及对路由进行缓存.这是一种页面加载的优化行为,允许你使用缓存后的路由,而不是每次请求都在服务器上进行渲染.<br> 为了全面了解这个工作过程,我们建议先来了解React是如何实现渲染,如何对这些渲染结果进行缓存的:</p><h3 id="_1-服务器上的渲染" tabindex="-1">1. 服务器上的渲染 <a class="header-anchor" href="#_1-服务器上的渲染" aria-label="Permalink to &quot;1. 服务器上的渲染&quot;">​</a></h3><p>在服务器上时,Next调用React APIs来组织各种渲染行为.渲染工作会被分为多个块进行(chunks):一种是单独的路由分块;另一种是带有Suspense边界的组件.<br> 每个块则会经由两个步骤渲染:</p><ol><li>React将服务器组件,渲染为一种特殊的数据格式.这种格式是专门为流式渲染所优化的,叫<code>React Server Component Payload, RSC Payload</code></li><li>Next使用上述的结果,RSC Payload,结合客户端组件指令,在服务器上初步渲染出HTML.</li></ol><p>也就是说我们不用等待所有内容都渲染好了后才对其进行缓存,才作出响应,而是流式地,将工作结果传递响应给客户端.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>React Server Component Payload是什么东西?</strong><br> RSC Payload是一种服务器组件树的二进制代表.服务于React,以更新客户端上的浏览器DOM.它包括:</p><ul><li>服务器组件的渲染结果</li><li>客户端组件的占位符,告知需要被渲染的位置在哪里,以及对应的JS文件是什么.</li><li>一些由服务器组件传递给客户端组件的props.<br> 更多相关内容可以去看<a href="https://nextjs.org/docs/app/building-your-application/rendering/server-components" target="_blank" rel="noreferrer">服务器组件的介绍文档</a>.</li></ul></div><h3 id="_2-next在服务器上的缓存-全路由缓存" tabindex="-1">2.Next在服务器上的缓存(全路由缓存) <a class="header-anchor" href="#_2-next在服务器上的缓存-全路由缓存" aria-label="Permalink to &quot;2.Next在服务器上的缓存(全路由缓存)&quot;">​</a></h3><p><img src="'+c+'" alt="full-route-cache"></p><p>Next的默认行为就会将路由渲染的结果缓存在服务器上(具体点就是RSC Payload和HTML).这种缓存机制适用于打包时的静态渲染路由或是重校验期间.</p><h3 id="_3-react在客户端上的水合和协调-hydration-and-reconciliation" tabindex="-1">3.React在客户端上的水合和协调(hydration and reconciliation) <a class="header-anchor" href="#_3-react在客户端上的水合和协调-hydration-and-reconciliation" aria-label="Permalink to &quot;3.React在客户端上的水合和协调(hydration and reconciliation)&quot;">​</a></h3><p>请求期间,客户端上会发生的事情:</p><ol><li>从服务器端返回的,快速的暂时无法交互的HTML先用于展示,这HTML属于客户端组件和服务器组件的预览.</li><li>RSC Payload会被用于协调客户端和渲染好的服务器组件树,并用来更新浏览器DOM.</li><li>Next使用JS指令,水合客户端组件,使页面变得最终可交互.</li></ol><h3 id="_4-客户端上的next缓存-路由器缓存" tabindex="-1">4.客户端上的Next缓存(路由器缓存) <a class="header-anchor" href="#_4-客户端上的next缓存-路由器缓存" aria-label="Permalink to &quot;4.客户端上的Next缓存(路由器缓存)&quot;">​</a></h3><p>RSC Payload会被存储在客户端<a href="https://nextjs.org/docs/app/building-your-application/caching#client-side-router-cache" target="_blank" rel="noreferrer">路由器缓存处</a> -- 一个以路由分块划分的,独立的内存缓存区.这个路由器缓存区以存储浏览过的路由,预获取可能要浏览的路由,两种方式来提升导航性能体验.</p><h3 id="_5-后续的导航" tabindex="-1">5.后续的导航 <a class="header-anchor" href="#_5-后续的导航" aria-label="Permalink to &quot;5.后续的导航&quot;">​</a></h3><p>在后续的导航或预获取路由期间,Next会检查路由器缓存区里是否已有对应的RSC Payload.如果已经有了,就直接从这里取而不不会向服务器发起请求.<br> 如果相应内容不存在于缓存中时,那Next就向服务器请求获取,将对应内容展示到客户端上.(populate the Router Cache?)</p><h3 id="静态渲染和动态渲染" tabindex="-1">静态渲染和动态渲染 <a class="header-anchor" href="#静态渲染和动态渲染" aria-label="Permalink to &quot;静态渲染和动态渲染&quot;">​</a></h3><p>路由是否会在构建时被缓存下来,取决于该路由是静态渲染,还是动态渲染的.静态路由默认就会被缓存下来;动态路由正则在请求周期内被渲染,不会被缓存.<br> 下图展示的是带有缓存数据/没有缓存数据的,静态渲染和动态渲染的路由区别: <img src="'+d+'" alt="static-and-dynamic-rendering"><a href="https://nextjs.org/docs/app/building-your-application/rendering/server-components#server-rendering-strategies" target="_blank" rel="noreferrer">更多关于静态渲染和动态渲染的内容</a></p><h3 id="持续时间-2" tabindex="-1">持续时间 <a class="header-anchor" href="#持续时间-2" aria-label="Permalink to &quot;持续时间&quot;">​</a></h3><p>默认全路由缓存是持久化的.也就是说渲染的结果会缓存于所有请求之间(across user requests).</p><h3 id="无效化" tabindex="-1">无效化 <a class="header-anchor" href="#无效化" aria-label="Permalink to &quot;无效化&quot;">​</a></h3><p>停用全路由缓存的方法有两种:</p><ul><li><a href="https://nextjs.org/docs/app/building-your-application/caching#revalidating" target="_blank" rel="noreferrer">重校验数据</a>:重校验数据缓存区会使路由器缓存区内容失效,因为会重渲染服务器上的组件,转而缓存新的渲染结果.</li><li>重新部署:不像数据缓存区那样,缓存的内容会在各个部署中都持久下来.全路由缓存每次部署都会被清空.</li></ul><h3 id="选择不使用功能" tabindex="-1">选择不使用功能 <a class="header-anchor" href="#选择不使用功能" aria-label="Permalink to &quot;选择不使用功能&quot;">​</a></h3><p>你可以选择不用全路由缓存,换句话说就是,每次请求都动态渲染组件,方式如下:</p><ul><li><strong>使用动态函数:</strong> 这就是显式表明不用全路由缓存,请求时动态渲染该路由了.此时数据缓存区还是可用的.</li><li><strong>使用路由分块配置<code>dynamic = &#39;force-dynmaic&#39;或&#39;revalidate = 0&#39;</code>:</strong> 这样配置会同时跳过全路由缓存和数据缓存.也就是说,每次向服务器请求时,组件都会被重新渲染,数据也会被重新获取.此时的路由器缓存是可用的,因为它是客户端上的缓存区.</li><li><strong>选择不使用数据缓存区:</strong> 如果路由中有<code>fetch</code>请求是不被缓存的,那么会致使该路由不使用全路由缓存这个功能.某些特定的<code>fetch</code>请求数据会在每次请求时重新获取.其它没有选择不用缓存的<code>fetch</code>请求,依旧会缓存于数据缓存区.也就产生一种&quot;混合&quot;的缓存行为,一些被缓存,另一些不被缓存.</li></ul>',78),u=[k];function g(b,m,y,f,x,E){return i(),e("div",null,u)}const _=a(p,[["render",g]]);export{F as __pageData,_ as default};
