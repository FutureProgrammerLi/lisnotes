import{_ as s,c as t,o as a,a3 as i}from"./chunks/framework.oAOP1Qjo.js";const e="/assets/caching-overview.oGsa81w4.jpg",n="/assets/deduplicated-fetch-requests.0cE0fW-n.jpg",m=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[],"relativePath":"react/Next/Official-Docs/Cache/Full-Content.md","filePath":"react/Next/Official-Docs/Cache/Full-Content.md"}'),h={name:"react/Next/Official-Docs/Cache/Full-Content.md"},l=i('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h1><p>Next通过缓存渲染内容及减少数据请求的方式,提升应用性能,减少工作花费.<br> 本文较为深入地介绍了,Next内部地缓存机制、一些配合使用的APIs,以及如何协调使用这些API配置.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>本页的内容是帮助你理解,Next底层的一些缓存工作原理的,非必要,对你产能可能没有帮助.<br> 大部分缓存的内容及实践,是由你如何使用API决定的.默认情况下Next已经帮你尽可能地将它们用于提供最好的性能配置了,你需要配置内容的可以说是没有,或是尽可能少了.<br> (大概这是我一直拖延翻译这章的一个理由?嗯对一定是)</p></div><h2 id="概况" tabindex="-1">概况 <a class="header-anchor" href="#概况" aria-label="Permalink to &quot;概况&quot;">​</a></h2><p>下图是对不同缓存机制以及相应操作目的的一个总结:</p><table><thead><tr><th>机制</th><th>是什么</th><th>在哪里执行</th><th>执行目的</th><th>执行持续时间</th></tr></thead><tbody><tr><td>&quot;记忆请求&quot;</td><td>函数的返回值</td><td>服务器上</td><td>在组件树内重用数据</td><td>每次请求周期</td></tr><tr><td>数据缓存</td><td>数据</td><td>服务器上</td><td>用户请求和部署期间存储数据</td><td>持久化存储(可被重校验)</td></tr><tr><td>完整路由缓存</td><td>HTML和RSC Payload</td><td>服务器上</td><td>减少渲染耗费的资源,提升性能</td><td>持久化存储(可被重校验)</td></tr><tr><td>路由器缓存</td><td>RSC Payload</td><td>客户端上</td><td>减少导航时向服务器发送的请求量</td><td>客户会话时间内,或是某个设定时间内</td></tr></tbody></table><p>Next默认会尽可能地对内容进行缓存,以提升应用性能及减少耗费.也就是说你不专门设置的话,<strong>路由会被静态渲染,数据请求会被缓存</strong>.下图展现的是默认缓存行为的工作过程:路由在构建时被静态渲染,以及首次访问一个静态路由的情况: <img src="'+e+'" alt="caching-overview"> 缓存的行为,取决于:1. 路由是静态/动态渲染;2. 数据是否需要被缓存;3. 某个请求,是初次访问就要用到/还是后续导航才用到.根据具体的使用场景,你可以为单独的路由/请求设置,单独地设置缓存行为.</p><h2 id="记忆请求-request-memoization" tabindex="-1">记忆请求(Request Memoization) <a class="header-anchor" href="#记忆请求-request-memoization" aria-label="Permalink to &quot;记忆请求(Request Memoization)&quot;">​</a></h2><p>Next扩展了<code>fetch</code>这个API,会自动地对请求进行&quot;记忆&quot;.同时也保留了原有的URL,配置选项设置.<br> 换句话说,你可以在组件树内,在不同地方调用获取相同数据的<code>fetch</code>请求.Next能确保<strong>它们只会被执行一次</strong>. <img src="'+n+`" alt="request-memoization"> 比如说你要在一个路由中使用相同的数据,(一个路由包括Layout,Page,多个Components等等..),你<strong>不需要</strong>在组件树的顶部请求数据,然后利用props传递给子组件.你可以直接在需要这些数据的组件中调用获取函数,不用担心可能会产生的多个重复请求造成性能的损耗问题.(你调用了多个请求,实质Next一个叛逆就不给你执行了.Next觉得你请求来的都是相同数据,所以选择缓存而不是&quot;亲力亲为&quot;).</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/example.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // \`fetch\`函数会被&quot;记忆&quot;,请求结果会被缓存.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 被调用了两次,但实际只会执行第一次.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cache MISS.缓存没有对应内容,&quot;亲力亲为&quot;去服务器请求数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cache HIT.缓存由对应请求及内容,选择使用缓存,不去发送真正的请求.</span></span></code></pre></div><h3 id="请求记忆是如何实现的" tabindex="-1">请求记忆是如何实现的? <a class="header-anchor" href="#请求记忆是如何实现的" aria-label="Permalink to &quot;请求记忆是如何实现的?&quot;">​</a></h3>`,11),p=[l];function d(r,k,o,c,g,u){return a(),t("div",null,p)}const E=s(h,[["render",d]]);export{m as __pageData,E as default};
