import{_ as i,c as a,a0 as e,o as t}from"./chunks/framework.CGHvQLJz.js";const n="/assets/use-client-directive.H4mIkcQD.jpg",g=JSON.parse('{"title":"客户端组件","description":"","frontmatter":{},"headers":[],"relativePath":"react/Next/Official-Docs/Rendering/ClientComponents.md","filePath":"react/Next/Official-Docs/Rendering/ClientComponents.md"}'),l={name:"react/Next/Official-Docs/Rendering/ClientComponents.md"};function r(o,s,p,h,k,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="客户端组件" tabindex="-1">客户端组件 <a class="header-anchor" href="#客户端组件" aria-label="Permalink to &quot;客户端组件&quot;">​</a></h1><p>客户端组件是一些可交互的界面部分,它们能在服务器上预渲染,也是浏览器内可运行的JS代码.(?)<br> 这篇文章主要介绍客户端组件是如何工作的,它们是如何被渲染的,以及何时你可以使用它们.</p><h2 id="客户端渲染的好处" tabindex="-1">客户端渲染的好处 <a class="header-anchor" href="#客户端渲染的好处" aria-label="Permalink to &quot;客户端渲染的好处&quot;">​</a></h2><p>在客户端上进行渲染的好处有以下:</p><ul><li><strong>可交互性:</strong> 客户端组件内可以使用状态,副作用,和时间监听器.也就是说它们能为用户提供即时的交互反馈,即时地进行界面更新.</li><li><strong>可用浏览器APIs:</strong> 客户端组件内可以使用浏览器自带的Api, 比如<a href="https://developer.mozilla.org/docs/Web/API/Geolocation_API" target="_blank" rel="noreferrer"><code>geolocation</code></a>,<a href="https://developer.mozilla.org/docs/Web/API/Window/localStorage" target="_blank" rel="noreferrer"><code>localStorage</code></a>等等.</li></ul><h2 id="next中使用客户端组件" tabindex="-1">Next中使用客户端组件 <a class="header-anchor" href="#next中使用客户端组件" aria-label="Permalink to &quot;Next中使用客户端组件&quot;">​</a></h2><p>要定义一个客户端组件,你需要在组件文件的最顶部(先于任何内容导入import),加一条<a href="https://react.dev/reference/react/use-client" target="_blank" rel="noreferrer"><code>&quot;use client&quot;</code></a>指令.<br><code>&quot;use client&quot;</code>这条命令的作用是,<a href="https://nextjs.org/docs/app/building-your-application/rendering#network-boundary" target="_blank" rel="noreferrer">明确划分</a>服务器组件和客户端组件.也就是说,一个文件中使用了这条命令,那么导入进这个文件的其它内容,包括子组件在内,都会被认为是客户端打包内容的部分.</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/counter.tsx</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;use client&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;first&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {counter} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;Click me&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>下图就说明了一个问题,如果你在嵌套组件(<code>toggle.js</code>)中用了<code>onClick</code>和<code>useState</code>,又没有明确定义<code>&quot;use client&quot;</code>的话,就会抛出错误.<strong>因为默认情况下,App Router下的所有组件都是服务器组件.</strong> 这些API它们是访问不到的.<br> 如果真的要在<code>toggle.js</code>内使用这些API,就声明该组件是客户端组件,顶部加上<code>&quot;use client&quot;</code>,这样它就能访问到了.<br><img src="`+n+'" alt="use-client-directive"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>定义多个<code>use client</code>入口</strong><br> 你可以在React组件树中定义多个<code>&quot;use client&quot;</code>入口.结果只是应用被分出了很多个客户端包而已.<br> 不过不过,又不用每一个需要在客户端渲染的组件,都加上<code>&quot;use client&quot;</code>这条声明.你在一个文件中使用了这个&quot;界限&quot;,那它所有的子组件,所有导入的模块,都已经被认为是客户端包的一部分了.</p></div><h2 id="客户端组件是如何被渲染的" tabindex="-1">客户端组件是如何被渲染的? <a class="header-anchor" href="#客户端组件是如何被渲染的" aria-label="Permalink to &quot;客户端组件是如何被渲染的?&quot;">​</a></h2><p>Next里的客户端组件渲染方式,视情况而不同:页面是否全部被渲染?(初次浏览或页面刷新) 后续路由切换导致组件重渲染?</p><h3 id="完整页面加载" tabindex="-1">完整页面加载 <a class="header-anchor" href="#完整页面加载" aria-label="Permalink to &quot;完整页面加载&quot;">​</a></h3><p>为了优化初次页面加载,Next会调用React APIs,在服务器上同时为客户端组件和服务器组件,渲染出一个静态的HTML预览页面.就是在用户首次浏览你的网站时,他们可以立即查看到页面的内容,不用等待浏览器下载解析执行客户端的JS组件包.</p><p>过程中服务器会发生的事情:</p><ol><li>React将服务器组件转变成一种特殊的数据格式,RSC Payload,其中就包括了客户端组件的索引(references)</li><li>Next结合RSC Payload和客户端组件JS指令,在服务器上为每个路由渲染出HTML.</li></ol><p>之后在客户端上:</p><ol><li>将以上的HTML立即展示给用户.虽然这个页面暂时是不可交互的,只是该路由的一个预览内容而已.</li><li>利用RSC Payload,对客户端组件树,和服务器组件树进行协调(reconcile),并更新DOM.</li><li>利用客户端组件JS指令,对客户端组件进行<a href="https://react.dev/reference/react-dom/client/hydrateRoot" target="_blank" rel="noreferrer">&quot;水合,注水&quot;(hydrate)</a>,使客户端组件真正变得可交互.</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>&quot;hydration&quot;, &quot;水合&quot;到底是什么?</strong><br> 水合是将事件监听器,添加到相应DOM上的一个过程,这样才能使静态HTML变得可以交互.<br> 实际上,水合过程利用的是<a href="https://react.dev/reference/react-dom/client/hydrateRoot" target="_blank" rel="noreferrer"><code>hydrateRoot</code></a>这个React API.</p></div><h3 id="后续路由切换的组件加载" tabindex="-1">后续路由切换的组件加载 <a class="header-anchor" href="#后续路由切换的组件加载" aria-label="Permalink to &quot;后续路由切换的组件加载&quot;">​</a></h3><p>如果是用户通过路由切换导致的客户端组件加载,那这个加载渲染过程完全是发生在客户端上的,不需要服务器渲染的HTML.<br> 这时的客户端包已经下载好,解析完了.当包一切都准备好后,React就利用RSC Payload,对客户端组件树和服务器组件树进行协调,更新DOM.</p><h2 id="回到服务器环境" tabindex="-1">回到服务器环境 <a class="header-anchor" href="#回到服务器环境" aria-label="Permalink to &quot;回到服务器环境&quot;">​</a></h2><p>有时候,你在某个组件内定义了<code>&quot;use client&quot;</code>边界,之后却又想回到服务器环境了:比如你为了减少客户端包的大小,在服务器上获取数据;或是要调用仅限服务器环境的API,那要怎么办呢?<br> 你可以保留这些,理论上嵌套在客户端组件内,仅服务器上可运行的代码,客户端组件,服务器组件,服务器行为穿插着用(???).<a href="https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns" target="_blank" rel="noreferrer">更多关于这种混合模式页面的内容</a>,在之后的篇幅再介绍.</p>',23)]))}const E=i(l,[["render",r]]);export{g as __pageData,E as default};
