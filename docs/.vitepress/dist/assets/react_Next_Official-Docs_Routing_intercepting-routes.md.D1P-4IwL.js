import{_ as o}from"./chunks/intercepted-routes-files.BpFdNxlm.js";import{_ as t,g as a,h as r,j as i}from"./app.DdR5laV-.js";import"./chunks/sidebar.6qxo-Q_S.js";const c="/assets/intercepting-routes-soft-navigate.CTFwm-4G.jpg",l="/assets/intercepting-routes-hard-navigate.B9iQT-Su.jpg",s="/assets/intercepted-routes-modal-example.DWTFyCfs.jpg",x=JSON.parse('{"title":"穿插路由","description":"","frontmatter":{},"headers":[],"relativePath":"react/Next/Official-Docs/Routing/intercepting-routes.md","filePath":"react/Next/Official-Docs/Routing/intercepting-routes.md","lastUpdated":1722948557000}'),d={name:"react/Next/Official-Docs/Routing/intercepting-routes.md"};function p(n,e,u,h,m,g){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="穿插路由" tabindex="-1">穿插路由 <a class="header-anchor" href="#穿插路由" aria-label="Permalink to &quot;穿插路由&quot;">​</a></h1><p>穿插路由(Intercepting routes)的意思是,允许你在当前布局下,加载来自应用另一部分的路由.这种路由行为(paradigm)用于不想用户切换上下文环境下,展示另一个路由的内容.<br> 比如说,你点击了评论区的一张照片,你可以以弹窗的形式展示它,将评论区覆盖在底部.这里就可以用到穿插路由:用<code>/photo/123</code>路由,暂时将<code>/feed</code>路由给覆盖起来. <img src="'+c+'" alt="intercept-routes"> 而如果直接通过分享而来的URL访问图片,或是打开了图片后进行页面刷新,页面则会展示整张图片而不是之前的弹窗.这种情况下不应产生路由穿插的情况. <img src="'+l+'" alt="no-intercept-routes"></p><h2 id="使用习惯" tabindex="-1">使用习惯 <a class="header-anchor" href="#使用习惯" aria-label="Permalink to &quot;使用习惯&quot;">​</a></h2><p><code>(..)folderName</code>,这是定义穿插路由的方法.这跟相对路径的命名方式相似(<code>../</code>),不过这次是针对分块而已.<br> 你可以这样用:</p><ul><li><code>(.)</code>,用来匹配相同等级的分块(segments)</li><li><code>(..)</code>,用来匹配上一级的分块</li><li><code>(..)(..)</code>,用来匹配上两级的分块</li><li><code>(...)</code>,用来匹配根目录<code>app</code>下的分块</li></ul><p>比如说你要在<code>feed</code>分块中,通过创建<code>(..)photo</code>目录的方式,穿插<code>photo</code>分块: <img src="'+o+'" alt="intercept-with-photo"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>(..)</code>这种命名习惯是基于路由分块的,不是基于文件系统的.</p></div><h2 id="使用例子" tabindex="-1">使用例子 <a class="header-anchor" href="#使用例子" aria-label="Permalink to &quot;使用例子&quot;">​</a></h2><h3 id="弹窗" tabindex="-1">弹窗 <a class="header-anchor" href="#弹窗" aria-label="Permalink to &quot;弹窗&quot;">​</a></h3><p>穿插路由可以搭配平行路由使用,用来创建弹窗.这能解决一些创建目录时经常遇到的问题,比如:</p><ul><li>使弹窗的内容,通过URL的方式,变得可以共享(shareable)</li><li>页面刷新时能够维持上下文,而不是将弹窗关掉</li><li>向后导航时关闭弹窗,而不时返回到先前的路由</li><li>向前导航时,重新打开弹窗</li></ul><p>思考以下的界面展示:用户既可以通过客户端导航的方式,在图片展(gallery)种打开图片弹窗,也可以直接通过URL,打开对应的图片: <img src="'+s+'" alt="modal-example"></p><p>上面的例子种,<code>photo</code>分块可以使用<code>(..)</code>匹配器.这是因为<code>@modal</code>只是一个插槽而不是一个实在的分块.换句话说,尽管看起来<code>photo</code>路由和<code>(..)photo</code>路由相差了两级,但实际上只是相差了一级.(所以用了<code>(..)</code>表示上一级)</p><p>你可以看看<a href="https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals" target="_blank" rel="noreferrer">平行路由的文档</a>,或者去<a href="https://github.com/vercel-labs/nextgram" target="_blank" rel="noreferrer">这个实例</a>了解一下.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>应用的另一例子是:登录弹窗既可以通过顶部导航栏打开(or somewhere else),也可以通过专门的<code>/login</code>路径访问专门的页面,或是在侧边栏弹窗内打开购物车.(?最后这个是什么意思)</p></div><h2 id="接下来" tabindex="-1">接下来 <a class="header-anchor" href="#接下来" aria-label="Permalink to &quot;接下来&quot;">​</a></h2><p>你可以通过结合平行路由和穿插路由的知识,创建自己的弹窗.</p><ul><li><a href="https://nextjs.org/docs/app/building-your-application/routing/parallel-routes" target="_blank" rel="noreferrer">平行路由</a></li></ul>',18)]))}const k=t(d,[["render",p]]);export{x as __pageData,k as default};
