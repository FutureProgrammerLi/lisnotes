import{_ as i,c as a,o as e,ak as n,br as t,bs as l,bt as p,bu as r,bv as h,bw as k,bx as d}from"./chunks/framework.BeJGjSYE.js";const F=JSON.parse('{"title":"页面加载和流(Streaming)","description":"","frontmatter":{},"headers":[],"relativePath":"react/Official-Docs/Next/Routing/loading-and-streaming.md","filePath":"react/Official-Docs/Next/Routing/loading-and-streaming.md","lastUpdated":1738226181000}'),c={name:"react/Official-Docs/Next/Routing/loading-and-streaming.md"};function o(g,s,E,b,m,u){return e(),a("div",null,s[0]||(s[0]=[n('<h1 id="页面加载和流-streaming" tabindex="-1">页面加载和流(Streaming) <a class="header-anchor" href="#页面加载和流-streaming" aria-label="Permalink to “页面加载和流(Streaming)”">​</a></h1><p>Next当中,<code>loading.js</code>是一个特殊的文件命名,它允许你搭配<a href="https://react.dev/reference/react/Suspense" target="_blank" rel="noreferrer"><code>React Suspense</code></a>来构建有意义的,加载中界面.<br> 有了这样的惯有行为,你就可以在页面内容加载的时候,展示一个即时的加载状态了.这个状态会在页面的内容完全渲染后,立马被替换掉. <img src="'+t+'" alt="loading-ui"></p><h2 id="即时的加载状态" tabindex="-1">即时的加载状态 <a class="header-anchor" href="#即时的加载状态" aria-label="Permalink to “即时的加载状态”">​</a></h2><p>即时加载状态,就是路由切换之后立刻显示出来的,后备的反馈页面而已.你可以预渲染一些加载指示器,像骨架屏,或是转圈指示器(spinner),又或是页面大概要展示的内容部分,这些告诉用户页面正在加载的技术.<br> 为页面添加加载中UI的方法很简单,就是在对应路由文件夹中创建<code>loading.js</code>文件: <img src="'+l+`" alt="loading-special-file"></p><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/dashboard/loading.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 任意用于提示界面正在加载的UI都是可以的.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LoadingSkeleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于<code>loading.js</code>和<code>layout.js</code>可能同级,前者会嵌套显示在后者当中.而<code>loading.js</code>的内容,又会自动包裹着<code>page.js</code>,以及任意处于<code>&lt;Suspense&gt;</code>界限之内的子内容. <img src="`+p+'" alt="loading-nesting"></p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><ul><li>导航都是即时发生的,哪怕你用的是App Router(Server-centric routing,围绕服务器端的路由?)</li><li>导航的过程是可干预的.也就是说一个路由的改变,不需要等到当前路由的内容完全加载,就可以切换到另一个新的路由了.</li><li>如果用的是相同的布局,那布局的内容在新的路由分块加载的时候,依旧是可使用,可互动的.</li></ul></div><div class="info custom-block"><p class="custom-block-title custom-block-title-default">INFO</p><p>建议: 能用<code>loading.js</code>命名就用这个命名,像<code>layout.js</code>和<code>page.js</code>那样,因为Next会优化它们的功能.(???)</p></div><h2 id="用挂起-suspense-实现流-streaming" tabindex="-1">用挂起(Suspense),实现流(Streaming) <a class="header-anchor" href="#用挂起-suspense-实现流-streaming" aria-label="Permalink to “用挂起(Suspense),实现流(Streaming)”">​</a></h2><p>除了使用<code>loading.js</code>这个基于文件的,添加页面加载中动画的功能外,你还可以手动为自己的UI组件设置挂起边界(Suspense Boundaries).App Router的挂起(Streaming with Suspense)功能在Node和Edge环境也是支持的.</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>一些浏览器中会对流回复(streaming response)进行缓存.你可能会看不到低于1024字节流回复.不过结果基本只会对比较小型的应用产生影响,对实际的应用很小可能实际产生影响.(?我都不懂什么是流回复)</p></div><h2 id="那-什么是流-streaming" tabindex="-1">那,什么是流(Streaming)? <a class="header-anchor" href="#那-什么是流-streaming" aria-label="Permalink to “那,什么是流(Streaming)?”">​</a></h2><p>如果要知道在React和Next之中,流是如何工作的,那就很有必要先了解一下什么是服务器渲染以及它的限制.(Server-Side Rendering,SSR).<br> 如果启用了服务器渲染,那就要在用户看到,交互到界面之前,多加一系列的步骤了:</p><ol><li>首先,某个特定页面的所有数据都先从服务器上获取.</li><li>之后,在服务器端上渲染HTML.</li><li>然后把对应页面的HTML,CSS,JS统统发送给客户.</li><li>用户收到一个暂时未可交互的界面,代码层面仅包含渲染好的HTML和CSS.</li><li>最后,React对页面内容进行&quot;注水&quot;(hydrate),这样界面才真正变得可交互.(hydrate的理解因人而异,我觉得像填充,liven,把字符串变成真正可执行的代码的过程)</li></ol><p><img src="'+r+'" alt="ssr-loading-procedure"></p><p>这些步骤是按顺序执行的,一步完成了才能进行下一步.也就是说只有当所有的数据都从服务器中拿到后,服务器才可能开始渲染HTML.以及在客户端方面,React只有在页面的所有组件都已下载后,才能进行&#39;hydrate(注水)&#39;操作,才能使页面变得可交互.<br> SSR的一个优点就是它减少了加载的时间,在服务器端渲染,然后先给到客户端一个可展示的界面内容.(是否可交互?另说,先展示了再说.) <img src="'+h+'" alt="ssr-without-streaming"></p><p>不过显然,串行的操作就有可能产生堵塞.必须先在服务器上获取所有的数据,才可能将页面展示给用户.<br> **流(Streaming)**的作用,就是允许你把页面的HTML,分解为多个更小的代码块(chunks),(progressively)增量地将这些分块从服务器端发送到客户端上. <img src="'+k+'" alt="ssr-with-streaming"> 这样页面的逐个部分就能更快地展示出来了,不用再等到所有的数据都获取到了才开始渲染UI.<br> 流的工作机制跟React的组件模型搭配得很好,因为每个组件本身就可以认为是一个块(chunk).一些比较重要的组件(比如产品信息)或是不依赖于数据的组件(比如布局文件),就可以先发送给客户端,React也就可以更早地进行&#39;注水&#39;了(hydrate).而那些不太重要地组件(比如评论,相关产品组件等)则可以在之后的服务器请求,对应的所有数据都已获取到之后,再发送回客户端.<br><img src="'+d+`" alt="ssr-with-streaming-chart"></p><p>当你的需要传输的数据大到阻塞了页面的渲染时,流的作用就非常明显了.它能降低TTFB和FCP这两个网页性能指标(Time To First Byte / First Contentful Paint).它也会减少TTI(Time to Interactive,步骤五,React对页面进行&#39;注水hydrate&#39;),对性能较差的设备尤其有用.</p><h2 id="举例" tabindex="-1">举例 <a class="header-anchor" href="#举例" aria-label="Permalink to “举例”">​</a></h2><p><code>&lt;Suspense&gt;</code>组件的工作机制,是先将需要执行异步操作的组件(比如获取数据)包裹起来,在异步操作的过程中展示一个加载中的提示界面,最后当异步操作完成后,再用组件的内容替换掉加载中的那个界面.</p><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/dashboard/page.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {Suspense} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {PostFeed, Weather} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./Components&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Posts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Loading feed...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PostFeed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Loading weather...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Weather</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">section</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>使用<code>&lt;Suspense&gt;</code>组件的好处有以下:</p><ol><li>流式化服务器渲染(Streaming Server Rendering) - 渐进式地从服务器渲染HTML页面,到客户端上.</li><li>选择性地&#39;注水&#39;(Selective hydration) - React将为你决定,用户界面的哪些组件需要先变得可交互,哪些组件的交互实现过程可以之后再实现.(步骤5)</li></ol><h2 id="搜索引擎优化-seo" tabindex="-1">搜索引擎优化(SEO) <a class="header-anchor" href="#搜索引擎优化-seo" aria-label="Permalink to “搜索引擎优化(SEO)”">​</a></h2><ul><li>Next将界面流式传输给客户端之前,还是会等待通过<code>generateMetadata</code>获取数据的完成的.这样才能保证第一个传输给客户端的流式相应(Streamed Response)中包含<code>&lt;head&gt;</code>标签.</li><li>尽管流是在服务器上渲染的,但它不会影响搜索引擎优化(SEO).你可以试试用Google的富结果测试工具(?Rich results Test tool)来测试你的Next应用,看看你的页面对于Google网页爬虫获得的内容及序列化的HTML长什么样.<a href="https://web.dev/rendering-on-the-web/#seo-considerations" target="_blank" rel="noreferrer">一些资料</a></li></ul><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to “状态码”">​</a></h2><p>流式传递时,响应码会是200,表明请求是成功的.<br> 服务器依旧可以通过流式内容,向客户端传递错误或是问题,比如使用了<code>redirect</code>或是<code>notFound</code>.由于响应头已经返回给客户端了,响应码自然是不能是更新的了.这还是不会影响SEO.(???你在说什么?303,307,404了你还是200,交流?交流了个什么???)</p>`,27)]))}const S=i(c,[["render",o]]);export{F as __pageData,S as default};
