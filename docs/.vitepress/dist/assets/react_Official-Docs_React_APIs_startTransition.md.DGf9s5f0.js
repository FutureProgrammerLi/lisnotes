import{_ as a}from"./app.DJMRJ_62.js";import{c as i,o as n,Z as t}from"./chunks/vendor.JG3V3vMx.js";const E=JSON.parse('{"title":"startTransition","description":"","frontmatter":{},"headers":[],"relativePath":"react/Official-Docs/React/APIs/startTransition.md","filePath":"react/Official-Docs/React/APIs/startTransition.md","lastUpdated":1738930721000}'),e={name:"react/Official-Docs/React/APIs/startTransition.md"};function l(r,s,p,h,k,o){return n(),i("div",null,s[0]||(s[0]=[t(`<h1 id="starttransition" tabindex="-1">startTransition <a class="header-anchor" href="#starttransition" aria-label="Permalink to &quot;startTransition&quot;">​</a></h1><blockquote><p>这个和<a href="./use.html"><code>use</code></a>一样,也是个API.<br> 对这个感兴趣是因为<code>useActionState</code>中提到,它返回的action用到表单时,会自动包裹到Transition中.<br><a href="#在-form-元素外调用服务器函数"><code>&#39;use server&#39;</code>指令介绍文</a>也提到,在表单外调用服务器函数时也要把该函数包裹到Transition中.遂有此文<br><a href="https://react.dev/reference/react/startTransition" target="_blank" rel="noreferrer">官方原文</a><br> 什么是Transition? <code>useTransition</code>又要如何使用?</p></blockquote><p><code>startTransition</code>可以让你在后台渲染部分UI界面.</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 番外:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// use(Promise) || use(Context)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><a href="#指引">指引</a><ul><li><a href="#starttransition-action"><code>startTransition(action)</code></a></li></ul></li><li><a href="#用法">用法</a><ul><li><a href="#把状态的更新标记为非阻塞transition">将状态的更新标记为不会阻塞的Transition</a><br> (转变? Transition又是什么?该如何译为中文?官方中文翻译也没翻出来)</li></ul></li></ul><h2 id="指引" tabindex="-1">指引 <a class="header-anchor" href="#指引" aria-label="Permalink to &quot;指引&quot;">​</a></h2><h2 id="starttransition-action" tabindex="-1"><code>startTransition(action)</code> <a class="header-anchor" href="#starttransition-action" aria-label="Permalink to &quot;\`startTransition(action)\`&quot;">​</a></h2><p><code>startTransition</code>可以让你把一些状态的更新标记为Transition.</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { startTransition } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TabContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> selectTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextTab);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h2><ul><li><code>action</code>: 一个通过调用<a href="https://react.dev/reference/react/useState#setstate" target="_blank" rel="noreferrer">一个或多个<code>set</code></a>以更新状态的函数.<br> (这里指<code>useState</code>返回的第二个参数:<code>const [state, setState] = useState(initialState);</code>中的<code>setState</code>)<br> React会立即调用不带参数的<code>action</code>,并对作为Transition的<code>action</code>内部的状态更新进行标记,把它们调度为同步更新(scheduled synchronously).<br> 所有<code>action</code>内的await异步调用,都会被包裹在transition中.不过以目前的实现,我们还需要把<code>await</code>后的<code>set</code>函数包裹到另外的<code>startTransition</code>中.(?<a href="https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition" target="_blank" rel="noreferrer">下面代码</a>是说明这个问题的,并非原文自带.)<br> 标记为Transition的状态更新,是<a href="https://react.dev/reference/react/startTransition#marking-a-state-update-as-a-non-blocking-transition" target="_blank" rel="noreferrer">不会阻塞的</a>,<a href="https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators" target="_blank" rel="noreferrer">不会展示任何不想要的加载指示器的</a>.</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someAsyncFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 以下的set function不会被标记为transition,你需要用额外的startTransition再包裹一次</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ❌</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someAsyncFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ✅</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>会出现以上问题,是因为Javascript的限制: React丢失了异步上下文中的作用域.<br> 未来如果<a href="https://github.com/tc39/proposal-async-context" target="_blank" rel="noreferrer"><code>AsyncContext</code></a>新功能实现了,我们就不再需要再包裹这一层了.</p><h2 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h2><p><code>startTransition</code>不会返回任何值.</p><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><ul><li><code>startTransition</code>不提供追踪Transition状态的方法.如果需要展示Transition的执行状态指示器,你需要使用<a href="https://react.dev/reference/react/useTransition" target="_blank" rel="noreferrer"><code>useTransition</code></a>替代.</li><li>你需要确保,将更新函数包裹到Transition之前,你是在这个更新函数的作用域之内的.如果你需要通过启用Transition,以响应一些prop或自定义hooks的返回值时,试试用<code>useDeferredValue</code>替代.</li><li>传给<code>startTransition</code>函数会被立即执行,对所有的状态更新进行标记,以Transitions的形式执行.如果你要在<code>setTimeout</code>里实现状态更新的话,这些更新不会被标记为Transition.</li><li>你必须把在异步函数之后的所有状态更新,都用另外的<code>startTransition</code>再包裹起来,把它们标记为Transitions.这个问题我们在上面也提过了,会在未来得到解决.</li><li>被标记为Transition的状态更新会被其它的状态更新所终端.比如你要在一个Transition里更新某个图表组件,在图标重渲染的过程中应用接收了用户的输入内容,React此时就会先优先处理用户的输入,之后再重启图表组件的渲染工作.</li><li>Transition内的更新函数不能用于控制文本输入.</li><li>如果同时有多个进行中的Transitions,React现在的处理方式是会同时批处理.这种处理方式之后可能会被变更.</li></ul><h2 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h2><h2 id="把状态的更新标记为非阻塞transition" tabindex="-1">把状态的更新标记为非阻塞Transition <a class="header-anchor" href="#把状态的更新标记为非阻塞transition" aria-label="Permalink to &quot;把状态的更新标记为非阻塞Transition&quot;">​</a></h2><p>你可以把状态的更新,用<code>startTransition</code>包裹起来,以标记为非阻塞的Transition.</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { startTransition } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TabContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> selectTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setTab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextTab);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>哪怕用户响应速度较为缓慢,Transitions的应用也可以确保界面的即时更新.<br> 用了Transition,你的界面就可以在重渲染之时,也保持响应性.比如当用户点击一个标签,然后突然改变主意,又点了另外的标签,此时这种操作是可行的,用户不必等待第一次点击导致的重渲染完成,也可以看到第二次点击的标签.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>startTransition</code>跟<code>useTransition</code>十分相似,只是前者不提供<code>isPending</code>标签,以追踪Transition的执行状态.你可以在不适用<code>useTransition</code>的情况下使用<code>startTransition</code>.比如组件定义之外的某些数据三方库(data library).</p><p><a href="https://react.dev/reference/react/useTransition" target="_blank" rel="noreferrer">关于Transitions及<code>useTransition</code></a></p></div>`,24)]))}const b=a(e,[["render",l]]);export{E as __pageData,b as default};
