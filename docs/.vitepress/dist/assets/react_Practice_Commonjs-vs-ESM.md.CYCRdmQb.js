import{_ as i}from"./app.E6B-SwxD.js";import{c as t,o as a,Z as e}from"./chunks/vendor.GdCD6OUn.js";const m=JSON.parse('{"title":"Commonjs vs ESM","description":"","frontmatter":{},"headers":[],"relativePath":"react/Practice/Commonjs-vs-ESM.md","filePath":"react/Practice/Commonjs-vs-ESM.md","lastUpdated":1738226181000}'),n={name:"react/Practice/Commonjs-vs-ESM.md"};function d(r,s,l,p,h,o){return a(),t("div",null,s[0]||(s[0]=[e(`<h1 id="commonjs-vs-esm" tabindex="-1">Commonjs vs ESM <a class="header-anchor" href="#commonjs-vs-esm" aria-label="Permalink to “Commonjs vs ESM”">​</a></h1><blockquote><p>是自己写express接口时遇到的一些很基础问题.记录一下加深了解</p></blockquote><h2 id="二者有什么区别" tabindex="-1">二者有什么区别? <a class="header-anchor" href="#二者有什么区别" aria-label="Permalink to “二者有什么区别?”">​</a></h2><p>来自后续自行了解的一些区别:</p><ol><li>来源不同, 语法不同;</li><li>环境不同;</li></ol><h2 id="来源不同-语法不同" tabindex="-1">来源不同,语法不同 <a class="header-anchor" href="#来源不同-语法不同" aria-label="Permalink to “来源不同,语法不同”">​</a></h2><p><strong>Commonjs是Node.js的社区规范, 主要语句是<code>require()</code>和<code>module.exports</code>;</strong><br> 它比ESM早出现,大概在2010年,是开发者们&quot;都同意使用&quot;的一套规范. 是在JS语法基础上,以函数的方式实现模块引入导出的方法.</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> express</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;express&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> express.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同一个文件中导出多个内容</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;abcd&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.add </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> add;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// module.exports = {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         add,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         name</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>ESM是JavaScript的官方标准, 主要语句是<code>import</code>和<code>export</code>;</strong><br> 是ES6的标准语法之一,即在2015年才出现. 它就是JS的语法.</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { add } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./add.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// export { add };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="环境不同" tabindex="-1">环境不同 <a class="header-anchor" href="#环境不同" aria-label="Permalink to “环境不同”">​</a></h2><p>程序执行有两种环境: 编译时和运行时.</p><ol><li>Commonjs是运行时加载</li><li>ESM是编译时加载</li></ol><p>ESM也可以使用<code>import()</code>函数实现动态加载.弥补ESM不能动态导入的缺陷.(利用这个方法实现运行时加载)</p><p>个人理解:</p><ol><li><code>require()</code>和<code>import()</code>是动态导入,所以不是必须要放到文件顶部.它们都可以放到条件语句或循环语句中. <code>import xxx from &#39;xxx&#39;</code>则必须放到文件顶部.</li><li>同步异步性: <ul><li><code>require()</code>和<code>import xxx from &#39;xxx&#39;</code>是同步的;</li><li><code>import(&#39;xxx&#39;)</code>是异步的;</li></ul></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>什么是运行时和编译时? 这是维基百科的解释:</p><ol><li><a href="https://en.wikipedia.org/wiki/Compile_time" target="_blank" rel="noreferrer">编译时</a></li><li><a href="https://en.wikipedia.org/wiki/Execution_(computing)#Runtime" target="_blank" rel="noreferrer">运行时</a></li></ol><p>编译时先于运行时. 编译产生的错误会导致程序无法启动运行;而运行时产生的错误,只有在该段出错代码被执行时才会使程序崩溃.(个人愚见)<br> 类型校验,变量注册,代码生成及优化,都是编译时需要完成的工作(也有个别例外).</p></div><h2 id="外部参考" tabindex="-1">外部参考 <a class="header-anchor" href="#外部参考" aria-label="Permalink to “外部参考”">​</a></h2><h3 id="文章" tabindex="-1">文章 <a class="header-anchor" href="#文章" aria-label="Permalink to “文章”">​</a></h3><p><a href="https://blog.csdn.net/qianyin925/article/details/144442868" target="_blank" rel="noreferrer">原文地址</a></p><table tabindex="0"><thead><tr><th></th><th>Commonjs</th><th>ESM</th></tr></thead><tbody><tr><td>语法</td><td><code>require()</code>,<code>module.exports</code></td><td><code>import</code>, <code>export</code></td></tr><tr><td>底层</td><td>普通函数</td><td>引擎语法底层支持</td></tr><tr><td>环境</td><td>运行时</td><td>编译时</td></tr><tr><td>缓存机制</td><td>有</td><td>有</td></tr><tr><td>导出数据格式</td><td>基本类型导出的是值的拷贝, 引用对象导出的是引用地址</td><td>导出的是值的引用地址(即动态绑定)</td></tr><tr><td>全局<code>this</code>指向</td><td>当前模块</td><td>等于<code>undefined</code> (?)</td></tr><tr><td>动态加载</td><td>支持</td><td><code>import xxx from &#39;xxx&#39;</code>是静态导入, 但<code>import(&#39;xxx&#39;)</code>是动态导入</td></tr><tr><td>循环引用</td><td>通过缓存机制实现,但可能取到空值</td><td>编译阶段就已经确定依赖关系,且值与变量是动态绑定的,不存在循环引用问题</td></tr></tbody></table><h3 id="from-chatgpt" tabindex="-1">from chatgpt: <a class="header-anchor" href="#from-chatgpt" aria-label="Permalink to “from chatgpt:”">​</a></h3><table tabindex="0"><thead><tr><th></th><th><code>require()</code></th><th><code>import xxx from &#39;xxx&#39;</code></th><th><code>import(&#39;xxx&#39;)</code></th></tr></thead><tbody><tr><td>规范</td><td>Commonjs</td><td>ESM</td><td>ESM</td></tr><tr><td>同步性</td><td>同步</td><td>同步</td><td>异步(返回一个<code>Promise</code>)</td></tr><tr><td>可用位置</td><td>任意处</td><td>只能文件顶部</td><td>任意处</td></tr><tr><td>Tree-shaking</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>加载时机</td><td>运行时</td><td>脚本初始化时</td><td>运行时(懒加载)</td></tr><tr><td>返回值</td><td>直接导出</td><td>直接导出</td><td>返回一个<code>Promise</code></td></tr><tr><td>浏览器兼容性</td><td>原生不支持</td><td>原生支持</td><td>原生支持</td></tr><tr><td>性能表现</td><td>直接加载完整模块,相较差</td><td>可用tree-shaking优化</td><td>可用懒加载优化</td></tr></tbody></table><p><strong>选用时机</strong>:</p><ul><li>旧老项目,或需要在较老的Nodejs版本环境中运行的代码,用<code>require()</code>;</li><li>新项目,需要立即加载某些模块并在文件内用到的,用<code>import xxx from &#39;xxx&#39;</code>;</li><li>需要动态导入,懒加载,条件加载等提升性能,减少初始代码加载量时,用<code>import(&#39;xxx&#39;)</code>;</li></ul>`,25)]))}const b=i(n,[["render",d]]);export{m as __pageData,b as default};
