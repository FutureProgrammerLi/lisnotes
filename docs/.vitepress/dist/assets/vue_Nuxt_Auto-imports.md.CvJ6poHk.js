import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.DPuwY6B9.js";const E=JSON.parse('{"title":"自动导入","description":"","frontmatter":{},"headers":[],"relativePath":"vue/Nuxt/Auto-imports.md","filePath":"vue/Nuxt/Auto-imports.md"}'),p={name:"vue/Nuxt/Auto-imports.md"};function e(l,s,h,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="自动导入" tabindex="-1">自动导入 <a class="header-anchor" href="#自动导入" aria-label="Permalink to &quot;自动导入&quot;">​</a></h1><blockquote><p><a href="https://nuxt.com/docs/guide/concepts/auto-imports" target="_blank" rel="noreferrer">https://nuxt.com/docs/guide/concepts/auto-imports</a></p></blockquote><p style="font-size:1.125rem;line-height:1.75rem;">Nuxt会自动导入一些组件,复用钩子,协助函数以及内置Vue API.</p><hr><p>Nuxt会自动引入组件,钩子(composables),以及内置API.不用手动声明引入,在你的vue文件内直接用就行了.</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>&quot;死板&quot;的目录结构有一点好处就是,<code>components/,composables/,utils/</code>这三个目录下的所有内容<strong>都会被自动引入.</strong><br> (Official Example里面没有这三个目录,你可以自己创建,只要目录名字是对的它就能全局引入).<br> 跟之前全局声明不一样的是,Nuxt保留了类型声明,IDE自动补全及提示,<strong>这些内容在生产环境中只有被使用的部分会被保留.</strong></p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p><code>server</code>目录下,Nuxt会自动引入<code>server/utils/</code>目录下导出的函数及变量.<br> 你可以自定义哪个文件夹内导出的内容,全局被使用:修改<code>nuxt.config</code>文件中的<code>imports</code>属性即可.</p></div><h2 id="内置自动引入" tabindex="-1">内置自动引入 <a class="header-anchor" href="#内置自动引入" aria-label="Permalink to &quot;内置自动引入&quot;">​</a></h2><p>Nuxt会自动引入一些用于函数及可复用钩子函数,这些函数一般用于数据获取,获取整个应用的上下文及运行时配置内容,管理状态或是定义组件和插件.</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">refresh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useFetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/api/hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>一些内置响应式API,像<code>ref</code>,<code>reactive</code>,或是生命周期钩子函数,辅助函数,这些也是直接暴露的,直接用就行.</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="vue和nuxt的可复用函数" tabindex="-1">Vue和Nuxt的可复用函数 <a class="header-anchor" href="#vue和nuxt的可复用函数" aria-label="Permalink to &quot;Vue和Nuxt的可复用函数&quot;">​</a></h2><p>你要用Vue和Nuxt内置的可复用函数时,应注意它们的使用需要在<em>正确的上下文环境</em>中才能发挥作用.<br> 在组件的生命周期内,Nuxt会用一个全局变量来跟踪当前的临时实例,<code>nuxtApp</code>,而在生命周期结束时取消跟踪(unsets in the same tick??怎么理解).这样做对于服务器渲染而言时很有必要的,一是可以避免跨组件状态请求污染(这个错误的结果是两个用户获得了同一个状态(!???!)),二是避免不同组件中状态的污染.<br> 换句话说就是,不要过多的指望自动引入给你带来的便利,这些自动导入的内容本身就不是到处都能被使用的:<strong>编写Nuxt插件,路由中间件,setup函数</strong> 里它们确实非常有用,所以一般限于这些范围之内.<br> 除此之外,你还需要同步地使用它们--<br><strong>除了在</strong></p><ul><li><code>&lt;script setup&gt;</code>,</li><li><code>defineNuxtComponent</code>,</li><li><code>defineNuxtPlugin</code>,</li><li><code>defineNuxtRouteMiddleware</code></li></ul><p>这些环境内,你不能不用await就调用一些异步钩子函数.我们在这些环境内都做了一些转变,把<code>await</code>后面的代码都保持同步执行.<br> (好拗口,但看例子也能看出来.<br> 上面的<code>useFetch</code>没有async声明也能用<code>await</code>,是因为它在规定的<code>&lt;script setup&gt;</code>环境之中.而这个环境是可以变化的,但又不是全部环境.尽量cover掉大部分的开发场景提供的便利吧算是)<br> 如果你开发遇到报错<code>Nuxt instance is unavailable</code>,大概是由于你在错误的环境中调用了Nuxt的钩子函数了(没在环境就直接用,你要手动声明引入才能解决)</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>⭐一个实验性的功能是,<a href="https://nuxt.com/docs/guide/going-further/experimental-features#asynccontext" target="_blank" rel="noreferrer">自定义这个异步环境</a>,硬要在没有<code>async</code>声明的环境下使用<code>await</code>,可复用钩子函数.</p></div><p>???为什么例子讲的不是一个东西?下面的代码说明的是<strong>要在自定义hooks内使用内置的钩子函数.</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// wrong 错误的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRuntimeConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMyWrongComposable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //  在这里用config</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//right, 正确的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMyRightComposable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //环境正确,可以正确获得运行时配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRuntimeConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="基于目录结构的自动引入" tabindex="-1">基于目录结构的自动引入 <a class="header-anchor" href="#基于目录结构的自动引入" aria-label="Permalink to &quot;基于目录结构的自动引入&quot;">​</a></h2><p>Nuxt会自动导入以下目录的所有文件:</p><ul><li><code>components/</code>,放Vue的组件;</li><li><code>composables/</code>,放自定义的Vue钩子函数;</li><li><code>utils/</code>,放一些协助函数或一些实用工具函数;</li></ul><h2 id="显式导入" tabindex="-1">显式导入 <a class="header-anchor" href="#显式导入" aria-label="Permalink to &quot;显式导入&quot;">​</a></h2><p>如果你的代码要给不熟悉Nuxt的人看的话,你可以显式的将Vue自动帮你导入的东西,手动声明导入.<br> 这些Nuxt自动导入的内容,显式导入的话在<code>#imports</code>这个别名包内.</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {ref,computed} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;#imports&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="禁止自动导入" tabindex="-1">禁止自动导入 <a class="header-anchor" href="#禁止自动导入" aria-label="Permalink to &quot;禁止自动导入&quot;">​</a></h2><p>当然自动导入这个功能是默认打开的.如果你要关闭它,可以在<code>nuxt.config</code>文件中,把<code>imports.autoImport</code>设置为<code>false</code>即可.</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    imports: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        autoImport:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>自动导入的所有东西都没有了(包括API及文件).不过你还可以从<code>#imports</code>这个包中手动导入你需要的东西.</p><h2 id="自动导入的组件" tabindex="-1">自动导入的组件 <a class="header-anchor" href="#自动导入的组件" aria-label="Permalink to &quot;自动导入的组件&quot;">​</a></h2><p>Nuxt自动导入<code>~/components</code>目录下的组件,它的配置跟自动导入的可复用hooks(composables)和工具函数(utils)是分开配置的.</p><details class="details custom-block"><summary>更多关于<a href="https://nuxt.com/docs/guide/directory-structure/components" target="_blank" rel="noreferrer">自动导入的组件内容,看这.</a></summary><p>略微看了下,组件的名称就是文件名.如果文件所在位置是多层目录下嵌套出来的,那就逐层叠加,即<code>组件名=一级目录名+二级目录名+3/4/5+文件名</code>, 当然首字母都是要大写的.<br> 比如<code>components/base/foo/bar.vue</code>,组件名就叫<code>&lt;BaseFooBar /&gt;</code><br> 要关掉组件名字根据目录名称嵌套组合,要配置:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    components:[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            path:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;~/components&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            pathPrefix:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></details><h2 id="自动导入第三方包" tabindex="-1">自动导入第三方包 <a class="header-anchor" href="#自动导入第三方包" aria-label="Permalink to &quot;自动导入第三方包&quot;">​</a></h2><p>要在Nuxt中自动导入第三方包也是可以的.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果你用的是Nuxt模块,那么大概你是不用手动再去配置什么了的,模块本身实现了自动导入包的功能.</p></div><p>举个例子就是,要从<code>vue-i18n</code>包中自动导入<code>useI18n</code>这个钩子,你可以这样写:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    imports:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        presets:[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                from:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue-i18n&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                imports:[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;useI18n&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div>`,38)]))}const c=i(p,[["render",e]]);export{E as __pageData,c as default};
