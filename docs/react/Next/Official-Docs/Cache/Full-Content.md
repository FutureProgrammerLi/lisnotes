# 缓存
Next通过缓存渲染内容及减少数据请求的方式,提升应用性能,减少工作花费.  
本文较为深入地介绍了,Next内部地缓存机制、一些配合使用的APIs,以及如何协调使用这些API配置.  

::: tip
本页的内容是帮助你理解,Next底层的一些缓存工作原理的,非必要,对你产能可能没有帮助.  
大部分缓存的内容及实践,是由你如何使用API决定的.默认情况下Next已经帮你尽可能地将它们用于提供最好的性能配置了,你需要配置内容的可以说是没有,或是尽可能少了.  
(大概这是我一直拖延翻译这章的一个理由?嗯对一定是)
:::

## 概况
下图是对不同缓存机制以及相应操作目的的一个总结:
| 机制   | 是什么 | 在哪里执行 | 执行目的 | 执行持续时间 |
| ---  | --- | --- | --- | --- |  
| "记忆请求"  | 函数的返回值 | 服务器上 | 在组件树内重用数据 | 每次请求周期 | 
| 数据缓存  | 数据 | 服务器上 | 用户请求和部署期间存储数据 | 持久化存储(可被重校验) | 
| 完整路由缓存  | HTML和RSC Payload | 服务器上 | 减少渲染耗费的资源,提升性能 | 持久化存储(可被重校验) | 
| 路由器缓存  | RSC Payload | 客户端上 | 减少导航时向服务器发送的请求量 | 客户会话时间内,或是某个设定时间内 | 

Next默认会尽可能地对内容进行缓存,以提升应用性能及减少耗费.也就是说你不专门设置的话,**路由会被静态渲染,数据请求会被缓存**.下图展现的是默认缓存行为的工作过程:路由在构建时被静态渲染,以及首次访问一个静态路由的情况:
![caching-overview](imgs/caching-overview.jpg)
缓存的行为,取决于:1. 路由是静态/动态渲染;2. 数据是否需要被缓存;3. 某个请求,是初次访问就要用到/还是后续导航才用到.根据具体的使用场景,你可以为单独的路由/请求设置,单独地设置缓存行为.

## 记忆请求(Request Memoization)
Next扩展了`fetch`这个API,会自动地对请求进行"记忆".同时也保留了原有的URL,配置选项设置.  
换句话说,你可以在组件树内,在不同地方调用获取相同数据的`fetch`请求.Next能确保**它们只会被执行一次**.
![request-memoization](imgs/deduplicated-fetch-requests.jpg)
比如说你要在一个路由中使用相同的数据,(一个路由包括Layout,Page,多个Components等等..),你**不需要**在组件树的顶部请求数据,然后利用props传递给子组件.你可以直接在需要这些数据的组件中调用获取函数,不用担心可能会产生的多个重复请求造成性能的损耗问题.(你调用了多个请求,实质Next一个叛逆就不给你执行了.Next觉得你请求来的都是相同数据,所以选择缓存而不是"亲力亲为").

```tsx
// app/example.tsx
async function getItem(){
    // `fetch`函数会被"记忆",请求结果会被缓存.
    const res = await fetch('https://...');
    return res.json();
}

// 被调用了两次,但实际只会执行第一次.
const item = await getItem();  // cache MISS.缓存没有对应内容,"亲力亲为"去服务器请求数据

const item = await getItem();  // cache HIT.缓存由对应请求及内容,选择使用缓存,不去发送真正的请求.
```

### 请求记忆是如何实现的?







