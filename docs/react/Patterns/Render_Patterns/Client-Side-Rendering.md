# 客户端渲染
> https://www.patterns.dev/react/client-side-rendering

如果你在React中使用了客户端渲染(Client-side Rendering,以下简称CSR)的方法,那服务器只会将页面的架构给渲染出来.**页面的逻辑,数据获取,模板以及路由等需要展现到页面的内容,都会交由客户端的JS代码来处理执行.**  
对于单页面应用,CSR是比较流行的一种方案.它令用户用起来感觉更像一个应用,而非一个简单的网页.  
为了更好地了解其它模式的优势,我们先来了解一下,客户端渲染这种方法有什么好处,又有什么缺陷.

## 基础结构
先用简单的代码来展示一下,用这种模式的代码结构是怎样的.以下是展示并更新当前时间:
```tsx
function tick(){
    const element = (
        <div>
            <h1>Hello World!</h1>
            <h2>It is {new Date().toLocaleTimeString()}.</h2>
        </div>
    );
    ReactDOM.render(element,document.getElementById('root'));
};

setInterval(tick,1000);
```
需要展示以上代码的HTML,只需一个id为`root`的`div`元素作为容器即可.内容的展示和更新完全交由Javascript来处理.这个页面的展示不需要与服务器交互,容器页面内容也能正确地实现更新.  
这里展示的内容可以不是时间,也可以是其它从API实时返回的汇率信息,股票价格等信息.它们都可以在不刷新页面,或与服务器交互的前提下实现内容的更新.

## Javascript包和性能表现
不过,当一个页面的复杂程度逐渐提升,既要渲染图片,也要从仓库获取数据,还要处理用户在网页上触发的事件时,网页的代码量和项目体积就难免同时攀升了.可能导致的结果就是项目打包后体积过大,导致首次内容绘制(FCP)和页面达到可交互时间(TTI)都变长了.  
(First Contentful Painting, Time To interactive,均为网页性能指标)
![Clientside-Rendering](/RenderPatterns/CSR.png)

如图片所示,当打包文件bundle.js体积增加时,FCP和TTI都会被推迟.也就是说页面加载时,用户就不得不看一段时间的白屏了.(FP到FCP,页面加载出来前一整段不明确的白屏时间)

## 好处和坏处
React大部分的应用逻辑都是直接在客户端上执行的,需要跟服务器交互的,一般是通过API从服务器获取数据,或向服务器发送存储数据.也就是说几乎所有界面的生成都是在客户端上完成.  
用户初次访问页面时,整个网页应用即从服务器请求返回.之后的导航,页面切换,网页都不再需要向服务器发起请求.视图/数据的变化都是在客户端上执行的.  

这样做的一个好处是,页面的导航切换不需要刷新了.而且,由于数据改变视图的范围是有限的(?),页面之间的路由看起来会更快,应用响应性会更好.对于开发人员而言,这种方式也更好地区分了客户端代码和服务器端代码.  

不过,正如每个硬币都有正反面,CSR也有其不足的地方:

1. **搜索引擎优化方面的顾虑(SEO,Search Engine Optimization)**:多数网页爬虫都是直接获取服务器渲染好的网页的.这对于CSR而言就有点尴尬了:大量的负载量和流水性的请求有可能导致网页有意义的内容渲染得不够迅速,致使爬虫软件无法对网页进行索引.爬虫软件可能能识别JS代码,但依旧存在限制.因此,CSR如果需要支持友好的SEO功能的话需要一些额外的操作.

2. **性能方面**:用CSR确实能在某些场景提供更丝滑的用户体验.不过这都是之后的事情了,在页面首次渲染到客户端时,用户不得不等待JS代码从服务器上加载并执行分析.开头就体验不好,就可能没有后续了.你不能保证当应用大到一定程度时,页面加载到客户端需要花费多少时间,用户愿意等多久,更不用说要加载到性能参差不齐的用户设备上了.  

3. **代码可维护性**: 虽说CSR将客户端代码和服务器端代码分开了,但更有可能的是,前后端用的语言并不是同一种.也就是说前后端为实现某功能而编写的代码可能会重复,实际上我们并不能清晰地将前后端逻辑代码分离开来.举例来说就是数据的校验,货币和日期的格式化代码逻辑.

4. **数据获取**: 客户端渲染的数据获取一般是事件驱动的(event-driven).页面初次加载时可以不从服务器获取任何数据,而在后续地网页事件中,触发了才去获取,比如页面的加载或触发API调用的按钮点击事件.你也不知道获取到的数据会是多少,也就是说这也有可能影响到用户加载/与应用交互所需要的时间.

不同的应用对以上的缺陷会有不同的影响程度和考虑.开发者一般都会寻求SEO友好的,加载页面更快而不用顾虑相应加载时间的解决办法.而且不同的性能指标在不同的应用需求中优先级也会有所不同.说不定CSR在当前场景下能达到瑕不掩瑜的效果呢?说不定真的需要其它的解决方案呢?

## 提升CSR性能
由于CSR的性能表现与代码打包的体积成反比,我们能做的是尽可能优化JS代码的结构.  

试着遵循一下以下准则,或许管用呢?
* **限制JS的大小**(Budgeting): 确保页面首次加载时JS的加载大小.一般首次加载包压缩后大小为<100 - 170 KB是一个不错的参考值.某些功能的代码可以之后再按需导入.

* **预加载**: 这种技术可以用来加载那些网页必须的资源,在网页周期开始之前就将它们加载进来.我们可以在HTML头部,在`\<head>`中使用以下指令加载这些必要资源:
```html
<link rel="preload" as="script" href="critical.js"/>
```
这条指令会告知浏览器,在页面渲染机制开始之前,加载`critical.js`文件.因此,该文件里的代码也会被提前变得可用,不会阻塞页面的渲染进程,从而提升网页性能

* **懒加载**:你可以用懒加载,将一些非必要的资源在需要的时候才对其进行加载.由于需要加载的资源少了,初次加载时间会随之减少.比如某个聊天小插件,在页面刚加载时是不需要的,我们就可以懒加载这个组件.

* **代码分块**: 为了避免JS包体积臃肿,你可以对包进行分块操作.你可以用像Webpack等的打包器,将代码分成多个块,在运行时再动态加载对应块.同时,代码分块使懒加载更加准确,进一步提升性能.

* **利用service works实现应用外壳缓存**: "应用外壳",就是形成一个页面所需的,最小量的HTML,CSS,JS代码所构成的网页.而如果利用Service Workers技术将这个外壳给缓存起来,则可达到离线浏览的效果.对于那些需要提供原生单页面应用体验,剩余内容需要渐进式加载的场景比较有用.

配合以上技术,CSR能更好地控制FCP和TTI指标,为用户提供较好的单页面应用体验.  
之后我们还会介绍与这种机制完全不同的渲染方式 -- 服务器渲染.